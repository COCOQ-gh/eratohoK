;-------------------------------------------------
;ARG:0勢力のAIの行動
;-------------------------------------------------
@AI_ACTION(ARG:0)

;ランダムキャラを使用している場合
IF FLAG:44
	;士官数が足りなければ士官を募集
	CALL RECRUIT_AI(ARG:0)
ENDIF

;国家間の隣接関係マップの作成(処理の高速化)
CALL TMP_CREATE_COUNTRY_NEIBORING_MAP

;{SLG_PP:0}期までは外交を行わない
IF DAY < SLG_PP:0
ELSE
	;外交の処理
	CALL AI_DIPLOMACY_ACT(ARG:0)
	;国家関係に変化があった場合
	IF RESULT
		;国家関係マップの再作成(処理の高速化)
		CALL TMP_CREATE_RELATION_MAP
	ENDIF
ENDIF

IF GET_OWN_CITY(ARG:0) > 0
	;部隊マップの作成(処理の高速化)
	CALL TMP_CREATE_UNIT_MAP
	;防衛を全て解除
	FOR LOCAL:0, 0, MAX_CITY
		IF CITY_OWNER:(LOCAL:0) == ARG:0
			;敵部隊のいる都市は解除不可
			IF !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
				COUNTRY_SOLDIER:(ARG:0) += CITY_SOLDIER:(LOCAL:0)
				CITY_SOLDIER:(LOCAL:0) = 0
				CITY_COMMANDER:(LOCAL:0) = 0
			ENDIF
		ENDIF
	NEXT
	FOR LOCAL:0, 0, 10
		;(LOCAL:0)番の部隊の存在判定　※最終決戦パッチ、FLAG:101の（勢力番号）ビットが1であればスキップ
		;最終決戦以外にも「野盗が中継点を占拠（つまりそこを通る旅人が陵辱される可能性もあるわけだ）」
		;「主人公勢力以外に複数勢力がある状態で特定勢力だけ決戦モード」に使えそうなので改造しました。
		IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0 && !GETBIT(FLAG:101, ARG:0)
			;部隊の所在地が敵対勢力でなければ解散する
			IF UNIT_POSITION:(ARG:0):(LOCAL:0) >= 0 && TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0))) >= 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;部隊の現在位置が地点かつ移動先を失っていれば解散する（強制解散フラグを使って時間を必要にするのも多分あり）
			ELSEIF !UNIT_TARGET:(ARG:0):(LOCAL:0) && CITY_TYPE:(UNIT_POSITION:(ARG:0):(LOCAL:0)) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			ENDIF
		ENDIF
	NEXT
	;DEBUGPRINTFORML %ANAME(GET_COUNTRY_BOSS(ARG:0))%
	;DEBUGPRINTFORML COUNTRY_SOLDIER:{COUNTRY_SOLDIER:(ARG:0)}
	;DEBUGPRINTFORML 最大:{GET_SUM_ECONOMY(ARG:0) / 10}

	CALL SLG_AI_SETDOCTRINE(ARG:0)
	CALL SLG_AI_RESCUE(ARG:0)

	SIF DAY >= SLG_PP:1
		CALL AI_DEPLOY_ARMY(ARG:0, 0)
	REPEAT 10
		CALL SLG_AI_INVASION_SETTARGET(ARG:0)
		SIF RESULT == 0
			BREAK
		CALL SLG_AI_INVASION_CREATEUNIT(ARG:0)
		SIF RESULT == 0
			BREAK
	REND

	SIF DAY >= SLG_PP:1
		CALL AI_DEPLOY_ARMY(ARG:0, 1)
	CALL SLG_AI_DEFENSE(ARG:0)
ENDIF

;-------------------------------------------------
;●防衛用の遊撃部隊を作成
;自軍の都市が攻撃を受けていれば防衛部隊を組織
;複数の都市が攻撃を受けている場合、都市を失った時に増加する戦線の数を基準に防衛の優先順位を決める
;-------------------------------------------------
@SLG_AI_RESCUE(ARG:0)
;切り返し戦術の攻撃兵数
#DIM REVERSE_SOLDIER
IS_PROTECTED = 0
LOCAL:5 = 0
LOCAL:6 = -999
FOR LOCAL:0, 0, MAX_CITY
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		LOCAL:(LOCAL:5 + 100) = LOCAL:0
		LOCAL:(LOCAL:5 + 200) = TMP_CHANGE_LINE_ONLOSE(LOCAL:0)
		IF LOCAL:(LOCAL:5 + 200) > LOCAL:6
			LOCAL:6 = LOCAL:(LOCAL:5 + 200)
		ENDIF
		LOCAL:5 ++
	ENDIF
NEXT

LOCAL:7 = 0
FOR LOCAL:0, 0, LOCAL:5
	IF LOCAL:(LOCAL:0 + 200) == LOCAL:6
		LOCAL:(LOCAL:7 + 300) = LOCAL:0
		LOCAL:7 ++
	ENDIF
NEXT

IF LOCAL:7 > 0
	;空いている部隊の番号のうち最も若い番号を取得
	LOCAL:10 = -1
	FOR LOCAL:0, 0, 10
		IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
			LOCAL:10 = LOCAL:0
			BREAK
		ENDIF
	NEXT

	IF LOCAL:10 >= 0
		LOCAL:8 = RAND:(LOCAL:7)
		LOCAL:9 = LOCAL:(LOCAL:8 + 100)

		UNIT_TARGET:(ARG:0):(LOCAL:10) = 0
		UNIT_POSITION:(ARG:0):(LOCAL:10) = LOCAL:9

		SELECTCASE CONFIG:300
		;簡単は全部隊の1/3を防衛に回す
		CASE 0
			UNIT_SOLDIER:(ARG:0):(LOCAL:10) = COUNTRY_SOLDIER:(ARG:0) / 3
		;簡単以外は全部隊の2/3を防衛に回す
		CASEELSE
			UNIT_SOLDIER:(ARG:0):(LOCAL:10) = COUNTRY_SOLDIER:(ARG:0) * 2 / 3
		ENDSELECT

		COUNTRY_SOLDIER:(ARG:0) -= UNIT_SOLDIER:(ARG:0):(LOCAL:10)

		;守るべき都市上にいる敵兵の総数を調べる
		LOCAL:3 = 0
		LOCAL:4 = 0
		LOCAL:5 = 0
		FOR LOCAL:0, 0, 20
			LOCAL:1 = TMP_UNIT_ONCITY_CNT:(LOCAL:9):(LOCAL:0)
			LOCAL:2 = TMP_UNIT_ONCITY_NUM:(LOCAL:9):(LOCAL:0)
			IF LOCAL:1 >= 1 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:1) == 0
				LOCAL:3 += UNIT_SOLDIER:(LOCAL:1):(LOCAL:2)
				IF UNIT_SOLDIER:(LOCAL:1):(LOCAL:2) > LOCAL:4
					LOCAL:4 = UNIT_SOLDIER:(LOCAL:1):(LOCAL:2)
					LOCAL:5 = LOCAL:1
				ENDIF
			ENDIF
		NEXT

		LOCAL:12 = 1
		;難易度が困難以上で敵部隊が防衛部隊の1/3未満
		IF CONFIG:300 >= 2 && LOCAL:3 * 3 < UNIT_SOLDIER:(ARG:0):(LOCAL:10)
			;部隊の半数を攻撃に回す
			REVERSE_SOLDIER = UNIT_SOLDIER:(ARG:0):(LOCAL:10) / 2
			UNIT_SOLDIER:(ARG:0):(LOCAL:10) -= REVERSE_SOLDIER

			;出撃先の都市を選択
			LOCAL:2 = 0
			FOR LOCAL:0, 1, MAX_CITY
				IF CITY_OWNER:(LOCAL:0) == LOCAL:5 && IS_ROOT(LOCAL:9, LOCAL:0)
					LOCAL:(LOCAL:2 + 100) = LOCAL:0
					LOCAL:2 ++
				ENDIF
			NEXT
			IF LOCAL:2 >= 1
				LOCAL:3 = LOCAL:(RAND:(LOCAL:2) + 100)

				;既に相手国家に部隊を送り込んでいるなら切り返さない
				LOCAL:4 = 1
				FOR LOCAL:0, 0, 10
					IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0 && CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0)) == LOCAL:3
						LOCAL:4 = 0
						BREAK
					ENDIF
				NEXT

				IF LOCAL:4
					;空いている部隊の番号のうち最も若い番号を取得
					LOCAL:11 = -1
					FOR LOCAL:0, 0, 10
						IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
							LOCAL:11 = LOCAL:0
							BREAK
						ENDIF
					NEXT

					IF LOCAL:11 >= 0
						;切り返し部隊を作成
						UNIT_SOLDIER:(ARG:0):(LOCAL:11) = REVERSE_SOLDIER
						UNIT_TARGET:(ARG:0):(LOCAL:11) = LOCAL:3
						UNIT_POSITION:(ARG:0):(LOCAL:11) = LOCAL:9

						;士官が行動可能な状態にあるかどうかのリストを作成
						CALL TMP_CREATE_IS_FREE_MAP

						;２部隊に載せる将を決定
						CALL CREATE_COMMANDER_LIST(ARG:0, 2)

						;防衛側の将を設定
						FOR LOCAL:0, 0, 3
							IF UNIT_COMMANDER_LIST:0:(LOCAL:0) >= 0
								CALL SET_UNIT_COMMANDER(ARG:0, LOCAL:10, LOCAL:0, UNIT_COMMANDER_LIST:0:(LOCAL:0))
							ENDIF
						NEXT

						;侵攻側の将を設定
						FOR LOCAL:0, 0, 3
							IF UNIT_COMMANDER_LIST:1:(LOCAL:0) >= 0
								CALL SET_UNIT_COMMANDER(ARG:0, LOCAL:11, LOCAL:0, UNIT_COMMANDER_LIST:1:(LOCAL:0))
							ENDIF
						NEXT

						;防衛部隊を作成したことを示すフラグ
						IS_PROTECTED = 1

						LOCAL:12 = 0
					ENDIF
				ENDIF
			ENDIF
		ENDIF

		;切り返し戦術をとらなかった場合
		IF LOCAL:12
			;士官が行動可能な状態にあるかどうかのリストを作成
			CALL TMP_CREATE_IS_FREE_MAP

			;部隊が最強となるような士官の組み合わせを得る
			CALL CHECK_UNIT_COMMANDER_BEST(ARG:0)
			FOR LOCAL:0, 0, 3
				SIF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
					CALL SET_UNIT_COMMANDER(ARG:0, LOCAL:10, LOCAL:0, UNIT_COMMANDER_BEST:(LOCAL:0))
			NEXT

			;防衛部隊を作成したことを示すフラグ
			IS_PROTECTED = 1
		ENDIF
	ENDIF
ENDIF


;-------------------------------------------------
;●防衛部隊の配分
;-------------------------------------------------
@SLG_AI_DEFENSE(ARG:0)
VARSET LOCAL
;敵勢力の都市と隣接する都市の探索
LOCAL:5 = 0
FOR LOCAL:0, 0, MAX_CITY
	;ARG:0勢力の都市で、敵部隊と交戦中でない
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		FOR LOCAL:1, 0, MAX_CITY
			;敵勢力の都市と隣接しているかをチェック
			IF CITY_OWNER:(LOCAL:1) != 0 && CITY_TYPE:(LOCAL:1) == 0 && IS_ROOT(LOCAL:0, LOCAL:1)
				IF TMP_COUNTRY_RELATION:(CITY_OWNER:(LOCAL:0)):(CITY_OWNER:(LOCAL:1)) == 0
					;敵勢力の都市と隣接する都市の番号をLOCAL:100～に順次記録していく
					LOCAL:(LOCAL:5 + 100) = LOCAL:0
					LOCAL:5 ++
					BREAK
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

;敵勢力からの距離が２の都市の探索(「敵都市に隣接する都市」に隣接)
LOCAL:6 = 0
FOR LOCAL:0, 0, MAX_CITY
	;ARG:0勢力の都市で、敵部隊と交戦中でない
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		;「敵都市に隣接する都市」として既に記録されているかをチェック
		LOCAL:9 = 1
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 100)
			IF LOCAL:0 == LOCAL:2
				LOCAL:9 = 0
				BREAK
			ENDIF
		NEXT

		;敵都市に隣接していない場合
		IF LOCAL:9
			FOR LOCAL:1, 0, LOCAL:5
				LOCAL:2 = LOCAL:(LOCAL:1 + 100)
				;「敵都市に隣接する都市」に隣接しているかをチェック
				IF IS_ROOT(LOCAL:0, LOCAL:2)
					;敵勢力からの距離が２の都市の番号をLOCAL:200～に順次記録していく
					LOCAL:(LOCAL:6 + 200) = LOCAL:0
					LOCAL:6 ++
					BREAK
				ENDIF
			NEXT
		ENDIF
	ENDIF
NEXT

;敵勢力からの距離が３以上の都市の探索(残りの都市)
LOCAL:7 = 0
FOR LOCAL:0, 0, MAX_CITY
	;ARG:0勢力の都市で、敵部隊と交戦中でない
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		;「敵都市に隣接する都市」として既に記録されているかをチェック
		LOCAL:8 = 1
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 100)
			IF LOCAL:0 == LOCAL:2
				LOCAL:8 = 0
				BREAK
			ENDIF
		NEXT

		IF LOCAL:8
			;「敵都市に隣接する都市」として既に記録されているかをチェック
			LOCAL:9 = 1
			FOR LOCAL:1, 0, LOCAL:6
				LOCAL:2 = LOCAL:(LOCAL:1 + 200)
				IF LOCAL:0 == LOCAL:2
					LOCAL:9 = 0
					BREAK
				ENDIF
			NEXT

			;どちらのリストにも記録されていない場合
			IF LOCAL:9
				;敵勢力からの距離が３以上の都市の番号をLOCAL:300～に順次記録していく
				LOCAL:(LOCAL:7 + 300) = LOCAL:0
				LOCAL:7 ++
			ENDIF
		ENDIF
	ENDIF
NEXT

;敵勢力に隣接する都市に重要度を付ける
LOCAL:10 = 0
FOR LOCAL:0, 0, LOCAL:5
	LOCAL:2 = LOCAL:(LOCAL:0 + 100)
	LOCAL:(LOCAL:0 + 400) = 100
	;占領されたときに増える戦線の数が多いほど重要
	LOCAL:(LOCAL:0 + 400) += MAX(TMP_CHANGE_LINE_ONLOSE(ARG:0, LOCAL:2), -1) * 30
	;勢力全体に占める経済規模の割合が高いほど重要
	LOCAL:(LOCAL:0 + 400) += CITY_ECONOMY:(LOCAL:2) * 100 / GET_SUM_ECONOMY(ARG:0)
	LOCAL:10 += LOCAL:(LOCAL:0 + 400)
NEXT

SELECTCASE CONFIG:300
;簡単
CASE 0
	;残った兵力を防衛に回す
	LOCAL:2 = COUNTRY_SOLDIER:(ARG:0) / (MAX(1, LOCAL:5 + LOCAL:6 + LOCAL:7))

	;どの都市も等分配
	FOR LOCAL:0, 0, LOCAL:5
		LOCAL:1 = LOCAL:(LOCAL:0 + 100)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	FOR LOCAL:0, 0, LOCAL:6
		LOCAL:1 = LOCAL:(LOCAL:0 + 200)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	FOR LOCAL:0, 0, LOCAL:7
		LOCAL:1 = LOCAL:(LOCAL:0 + 300)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	;重要度の高い都市から順に守将を決定
	LOCAL:15 = LOCAL:5
	FOR LOCAL:0, 0, LOCAL:15
		LOCAL:16 = 0
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 400)
			IF LOCAL:2 > LOCAL:16
				LOCAL:16 = LOCAL:2
				LOCAL:17 = LOCAL:1
			ENDIF
		NEXT
		CALL TMP_CREATE_IS_FREE_MAP
		CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100))
		FOR LOCAL:1, LOCAL:17, LOCAL:5
			LOCAL:(LOCAL:1 + 100) = LOCAL:(LOCAL:1 + 101)
			LOCAL:(LOCAL:1 + 400) = LOCAL:(LOCAL:1 + 401)
		NEXT
		LOCAL:5 --
	NEXT
;普通
CASE 1
	;残った兵力を防衛に回す
	LOCAL:2 = COUNTRY_SOLDIER:(ARG:0) / (MAX(1, LOCAL:5 * 2 + LOCAL:6 + LOCAL:7))

	;敵勢力と隣接する都市への割り振り
	FOR LOCAL:0, 0, LOCAL:5
		LOCAL:1 = LOCAL:(LOCAL:0 + 100)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2 * 2 * LOCAL:(LOCAL:0 + 400) * LOCAL:5 / LOCAL:10
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;敵勢力からの距離が２、３の都市への割り振り
	FOR LOCAL:0, 0, LOCAL:6
		LOCAL:1 = LOCAL:(LOCAL:0 + 200)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	FOR LOCAL:0, 0, LOCAL:7
		LOCAL:1 = LOCAL:(LOCAL:0 + 300)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	;重要度の高い都市から順に守将を決定
	LOCAL:15 = LOCAL:5
	FOR LOCAL:0, 0, LOCAL:15
		LOCAL:16 = 0
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 400)
			IF LOCAL:2 > LOCAL:16
				LOCAL:16 = LOCAL:2
				LOCAL:17 = LOCAL:1
			ENDIF
		NEXT
		CALL TMP_CREATE_IS_FREE_MAP
		;防衛AIは武将の数に余裕があると二人配置する
		IF COUNTRY_AI_TYPE:(ARG:0) == AI_防衛
			IF TMP_GET_IS_FREE_NUM(ARG:0) >= LOCAL:5 + 1
				CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 1)
			ELSE
				CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 0)
			ENDIF
		ELSE
			CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 0)
		ENDIF
		FOR LOCAL:1, LOCAL:17, LOCAL:5
			LOCAL:(LOCAL:1 + 100) = LOCAL:(LOCAL:1 + 101)
			LOCAL:(LOCAL:1 + 400) = LOCAL:(LOCAL:1 + 401)
		NEXT
		LOCAL:5 --
	NEXT

;困難・虐め
CASEELSE
	;距離３以上の都市に各々500の兵を配分
	FOR LOCAL:0, 0, LOCAL:7
		LOCAL:1 = LOCAL:(LOCAL:0 + 300)
		CITY_SOLDIER:(LOCAL:1) = MIN(500, COUNTRY_SOLDIER:(ARG:0))
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;残った兵力を防衛に回す
	LOCAL:2 = COUNTRY_SOLDIER:(ARG:0) / (MAX(1, LOCAL:5 * 5 + LOCAL:6 * 2))

	;敵勢力と隣接する都市への割り振り
	FOR LOCAL:0, 0, LOCAL:5
		LOCAL:1 = LOCAL:(LOCAL:0 + 100)
		CITY_SOLDIER:(LOCAL:1) += LOCAL:2 * 5 * LOCAL:(LOCAL:0 + 400) * LOCAL:5 / LOCAL:10
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;敵勢力からの距離が２の都市への割り振り
	FOR LOCAL:0, 0, LOCAL:6
		LOCAL:1 = LOCAL:(LOCAL:0 + 200)
		CITY_SOLDIER:(LOCAL:1) += LOCAL:2 * 2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;重要度の高い都市から順に守将を決定
	LOCAL:15 = LOCAL:5
	FOR LOCAL:0, 0, LOCAL:15
		LOCAL:16 = 0
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 400)
			IF LOCAL:2 > LOCAL:16
				LOCAL:16 = LOCAL:2
				LOCAL:17 = LOCAL:1
			ENDIF
		NEXT
		CALL TMP_CREATE_IS_FREE_MAP
		;全てのAIは武将の数に余裕があると二人配置する
		IF TMP_GET_IS_FREE_NUM(ARG:0) >= LOCAL:5 + 1
			CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 1)
		ELSE
			CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 0)
		ENDIF
		FOR LOCAL:1, LOCAL:17, LOCAL:5
			LOCAL:(LOCAL:1 + 100) = LOCAL:(LOCAL:1 + 101)
			LOCAL:(LOCAL:1 + 400) = LOCAL:(LOCAL:1 + 401)
		NEXT
		LOCAL:5 --
	NEXT
ENDSELECT

;-------------------------------------------------
;作成可能な部隊のうち能力が最強となる将の組み合わせを調べる ARG:0=勢力番号 ARG:1 = 政治力によるフィルタを無視するフラグ
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CHECK_UNIT_COMMANDER_BEST(ARG:0, ARG:1 = 0)
;候補キャラのキャラ番号及びそのキャラの各パワーを記録する配列
;一次配列でそれぞれ用意しているのは配列検索系の関数を利用するため
#DIM CHECK_IS_FREE, 1000
#DIM FREE_STR, 1000
#DIM FREE_INT, 1000
#DIM FREE_MAG, 1000
#DIM FREE_POL, 1000
#DIM FREE_AI_PRIORITY, 3
;候補キャラのパワー上昇率と政治パワー合計
#DIM FREE_PUP, 1000
#DIM SUM_POL

VARSET CHECK_IS_FREE, -1
VARSET UNIT_COMMANDER_BEST, -1
VARSET LOCAL, -1
VARSET FREE_STR, -1
VARSET FREE_INT, -1
VARSET FREE_MAG, -1
VARSET FREE_POL, -1
VARSET FREE_PUP, -1
VARSET FREE_AI_PRIORITY, 10

LOCAL:1 = 0
FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
	;自国の士官のみ考慮
	IF CFLAG:(LOCAL:0):1 == ARG:0 && TMP_IS_FREE:(LOCAL:0):0 == 0
		;MASTER麾下の武将は、除外フラグをたてていたら除外する
		SIF ARG:0 == CFLAG:MASTER:所属 && CFLAG:(LOCAL):最強編成除外フラグ
			CONTINUE
		;自由に行動可能なキャラ番号をCHECK_IS_FREEに順番に格納
		CHECK_IS_FREE:(LOCAL:1) = LOCAL:0
		LOCAL:1 ++
	ENDIF
NEXT

SUM_POL = 0


FOR LOCAL:0, 0, LOCAL:1
	;別変数に一旦格納
	LOCAL:2 = CHECK_IS_FREE:(LOCAL:0)
	FREE_STR:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):武闘, LOCAL:2)
	FREE_INT:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):知略, LOCAL:2)
	FREE_MAG:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):妖術, LOCAL:2)
	FREE_POL:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):政治, LOCAL:2)
	;特殊勢力のキャラなら、各パワーを1にし、通常キャラが優先されるようにしておく。
	IF TALENT:(LOCAL:2):野盗 || TALENT:(LOCAL:2):外来人 || TALENT:(LOCAL:2):ホフゴブリン
		FREE_STR:(LOCAL:0) = 1
		FREE_INT:(LOCAL:0) = 1
		FREE_MAG:(LOCAL:0) = 1
		;政治パワーを非常に高くしておいて、通常キャラが政治パワーを理由に除外されないようにする
		FREE_POL:(LOCAL:0) *= 10
	ENDIF
	SUM_POL += FREE_POL:(LOCAL:0)
NEXT


IF !ARG:1
	FOR LOCAL:0, 0, LOCAL:1
		;行動可能なキャラの政治パワー合計のうち一定割合を占めているキャラを除外
		IF FREE_POL:(LOCAL:0) > AI_POLITICAL_LIMIT:(COUNTRY_AI_TYPE:(ARG:0)) * SUM_POL / 100
			FREE_STR:(LOCAL:0) = 0
			FREE_INT:(LOCAL:0) = 0
			FREE_MAG:(LOCAL:0) = 0
			FREE_POL:(LOCAL:0) = -1
		ENDIF
	NEXT
ENDIF

;武闘・知略・妖術の最大値を比較し最も大きい値を持つキャラを候補にする
LOCAL:10 = MAXARRAY(FREE_STR)
LOCAL:20 = MAXARRAY(FREE_INT)
LOCAL:30 = MAXARRAY(FREE_MAG)

;重視率のゆらぎ80～120%
FREE_AI_PRIORITY:0 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):0 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:1 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):1 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:2 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):2 * (80 + RAND:41) / 100

SIF ALLSAMES(LOCAL:10, LOCAL:20, LOCAL:30) && LOCAL:10 == -1
	RETURN 1
;AI毎に各パワーに重みをもたせて重視する能力を変化させている
;FREE_XXX及びCHECK_IS_FREEの配列は要素の位置が同じなら同じキャラのデータをとるのを利用
IF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:20 * FREE_AI_PRIORITY:1
	IF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:30 * FREE_AI_PRIORITY:2
		LOCAL:50 = FINDELEMENT(FREE_STR, LOCAL:10)
	ELSE
		LOCAL:50 = FINDELEMENT(FREE_MAG, LOCAL:30)
	ENDIF
ELSE
	LOCAL:50 = FINDELEMENT(FREE_INT, LOCAL:20)
ENDIF

UNIT_COMMANDER_BEST:0 = CHECK_IS_FREE:(LOCAL:50)

IF UNIT_COMMANDER_BEST:0 >= 0
	;１人目のキャラを候補から外す（政治パワーにフラグをつける）
	FREE_POL:(LOCAL:50) = -1

	;アップ率の合計が最も大きいキャラを次の候補にする
	LOCAL:40 = 0
	LOCAL:41 = -1
	FOR LOCAL:0, 0, LOCAL:1
		;候補に残っているキャラのみを考慮
		SIF FREE_POL:(LOCAL:0) < 0 || LOCAL:50 == LOCAL:0
			CONTINUE
		LOCAL:12 = MAX(FREE_STR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:0 / FREE_STR:(LOCAL:50)
		LOCAL:22 = MAX(FREE_INT:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:1 / FREE_INT:(LOCAL:50)
		LOCAL:32 = MAX(FREE_MAG:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:2 / FREE_MAG:(LOCAL:50)
		FREE_PUP:(LOCAL:0) = LOCAL:12 + LOCAL:22 + LOCAL:32
	NEXT
	LOCAL:51 = FINDELEMENT(FREE_PUP,  MAX(MAXARRAY(FREE_PUP), 0))
	;２人目のキャラを記録し候補から外す
	UNIT_COMMANDER_BEST:1 = LOCAL:51 >= 0 ? CHECK_IS_FREE:(LOCAL:51) # -1
	IF UNIT_COMMANDER_BEST:1 >= 0
		FREE_POL:(LOCAL:51) = -1

		LOCAL:13 = FREE_STR:(LOCAL:50) + FREE_STR:(LOCAL:51)
		LOCAL:23 = FREE_INT:(LOCAL:50) + FREE_INT:(LOCAL:51)
		LOCAL:33 = FREE_MAG:(LOCAL:50) + FREE_MAG:(LOCAL:51)
	ENDIF

	VARSET FREE_PUP, -1

	;アップ率の合計が最も大きいキャラを次の候補にする(３人目は歌唱・料理も考慮、外来人とホフゴブ、野盗を優先)
	LOCAL:8 = 0
	IF LOCAL:50 < 0 || (!TALENT:(CHECK_IS_FREE:(LOCAL:50)):外来人 && !TALENT:(CHECK_IS_FREE:(LOCAL:50)):ホフゴブリン && !TALENT:(CHECK_IS_FREE:(LOCAL:50)):野盗)
		IF LOCAL:51 < 0 || (!TALENT:(CHECK_IS_FREE:(LOCAL:51)):外来人 && !TALENT:(CHECK_IS_FREE:(LOCAL:51)):ホフゴブリン && !TALENT:(CHECK_IS_FREE:(LOCAL:51)):野盗)
			LOCAL:8 = 1
		ENDIF
	ENDIF
	FOR LOCAL:0, 0, LOCAL:1
		;候補に残っているキャラのみを考慮
		SIF FREE_POL:(LOCAL:0) < 0 || GROUPMATCH(LOCAL:0, LOCAL:50, LOCAL:51)
			CONTINUE
		LOCAL:2 = CHECK_IS_FREE:(LOCAL:0)
		LOCAL:12 = MAX(FREE_STR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:13 * FREE_AI_PRIORITY:0
		LOCAL:22 = MAX(FREE_INT:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:23 * FREE_AI_PRIORITY:1
		LOCAL:32 = MAX(FREE_MAG:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:33 * FREE_AI_PRIORITY:2
		LOCAL:42 = (MAX(ABL_POWER_X(ABL:(LOCAL:2):歌唱, LOCAL:2) - ABL_50_POWER, 0) + 24000) / 24 - 1000
		LOCAL:52 = (MAX(ABL_POWER_X(ABL:(LOCAL:2):料理, LOCAL:2) - ABL_50_POWER, 0) + 24000) / 24 - 1000
		FREE_PUP:(LOCAL:0) = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42 + LOCAL:52

		IF (TALENT:(CHECK_IS_FREE:(LOCAL:0)):外来人 || TALENT:(CHECK_IS_FREE:(LOCAL:0)):ホフゴブリン || TALENT:(CHECK_IS_FREE:(LOCAL:0)):野盗) && LOCAL:8
			FREE_PUP:(LOCAL:0) = __INT_MAX__
			BREAK
		ENDIF

	NEXT
	LOCAL:52 = FINDELEMENT(FREE_PUP, MAX(MAXARRAY(FREE_PUP), 0))

	;３人目のキャラを記録
	UNIT_COMMANDER_BEST:2 = LOCAL:52 >= 0 ? CHECK_IS_FREE:(LOCAL:52) # -1

	IF UNIT_COMMANDER_BEST:1 < 0 && UNIT_COMMANDER_BEST:2 >= 0
		UNIT_COMMANDER_BEST:1 = UNIT_COMMANDER_BEST:2
		UNIT_COMMANDER_BEST:2 = -1
	ENDIF
ELSE
;	DEBUGPRINTFORML {DAY, 3}【編成武将候補なし】:%NAME:(GET_COUNTRY_BOSS(ARG:0))%
	
ENDIF

;SIF !NOSAMES(LOCAL:50, LOCAL:51, LOCAL:52)
;	DEBUGPRINTFORML {DAY, 3}【武将重複？】:%NAME:(GET_COUNTRY_BOSS(ARG:0))%@ {LOCAL:50}:{CHECK_IS_FREE:(LOCAL:50)}, {LOCAL:51}:{CHECK_IS_FREE:(LOCAL:51)}, {LOCAL:52}:{CHECK_IS_FREE:(LOCAL:52)}

;最後にNO順に並べ替える
FOR LOCAL:0, 0, 3
	IF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
		FOR LOCAL:1, LOCAL:0 + 1, 3
			IF UNIT_COMMANDER_BEST:(LOCAL:1) >= 0
				IF NO:(UNIT_COMMANDER_BEST:(LOCAL:0)) > NO:(UNIT_COMMANDER_BEST:(LOCAL:1))
					SWAP UNIT_COMMANDER_BEST:(LOCAL:0), UNIT_COMMANDER_BEST:(LOCAL:1)
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

;-------------------------------------------------
;部隊に配置する将の組み合わせ候補のリストを作成 ARG:0=勢力番号 ARG:1=作成する部隊の数
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CREATE_COMMANDER_LIST(ARG:0, ARG:1)
;キャラが候補として残っているかどうかを記録する変数
#DIM CHECK_IS_FREE, 1000

VARSET CHECK_IS_FREE, 0

FOR LOCAL:0, 0, 10
	FOR LOCAL:1, 0, 3
		UNIT_COMMANDER_LIST:(LOCAL:0):(LOCAL:1) = -1
	NEXT
NEXT

FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
	;自国の士官のみ考慮
	IF CFLAG:(LOCAL:0):1 == ARG:0
		;自由に行動可能なら候補フラグを立てる
		CHECK_IS_FREE:(LOCAL:0) = (TMP_IS_FREE:(LOCAL:0):0 == 0)
	ENDIF
NEXT

FOR LOCAL:1, 0, ARG:1
	LOCAL:10 = ABL_50_POWER
	LOCAL:20 = ABL_50_POWER
	LOCAL:30 = 0
	LOCAL:11 = -1
	LOCAL:21 = -1
	LOCAL:31 = -1
	FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
		;候補に残っているキャラのみを考慮
		IF CHECK_IS_FREE:(LOCAL:0)
			LOCAL:12 = ABL_POWER_X(ABL:(LOCAL:0):武闘, LOCAL:0)
			LOCAL:22 = ABL_POWER_X(ABL:(LOCAL:0):知略, LOCAL:0)
			LOCAL:32 = ABL_POWER_X(ABL:(LOCAL:0):妖術, LOCAL:0)
			;武闘パワーが最大のキャラとその値を取得
			IF LOCAL:12 > LOCAL:10
				LOCAL:10 = LOCAL:12
				LOCAL:11 = LOCAL:0
			ENDIF
			;知略パワーが最大のキャラとその値を取得
			IF LOCAL:22 > LOCAL:20
				LOCAL:20 = LOCAL:22
				LOCAL:21 = LOCAL:0
			ENDIF
			;妖術パワーが最大のキャラとその値を取得
			IF LOCAL:32 > LOCAL:30
				LOCAL:30 = LOCAL:32
				LOCAL:31 = LOCAL:0
			ENDIF
		ENDIF
	NEXT

	;武闘最大値と知略最大値を比較し大きい方を持つキャラを１人目にする
	IF LOCAL:10 >= LOCAL:20
		IF LOCAL:10 >= LOCAL:30
			UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:11
		ELSE
			UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:31
		ENDIF
	ELSE
		UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:21
	ENDIF

	IF UNIT_COMMANDER_LIST:(LOCAL:1):0 >= 0
		;選んだキャラを候補から外す
		CHECK_IS_FREE:(UNIT_COMMANDER_LIST:(LOCAL:1):0) = 0
	ENDIF
NEXT

FOR LOCAL:2, 1, 3
	FOR LOCAL:1, 0, ARG:1
		;アップ率の合計が最も大きいキャラを２・３人目の候補にする(歌唱・料理も考慮)
		LOCAL:80 = 0
		LOCAL:81 = -1
		LOCAL:5 = UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2 - 1)
		LOCAL:6 = UNIT_COMMANDER_LIST:(LOCAL:1):0
		LOCAL:7 = UNIT_COMMANDER_LIST:(LOCAL:1):1
		LOCAL:8 = 0
		IF (LOCAL:6 < 0 || !TALENT:(LOCAL:6):外来人) && (LOCAL:7 < 0 || !TALENT:(LOCAL:7):外来人)
			LOCAL:8 = 1
		ENDIF

		IF LOCAL:5 >= 0
			LOCAL:13 = ABL_POWER_X(ABL:(LOCAL:5):武闘, LOCAL:5)
			LOCAL:23 = ABL_POWER_X(ABL:(LOCAL:5):知略, LOCAL:5)
			LOCAL:33 = ABL_POWER_X(ABL:(LOCAL:5):妖術, LOCAL:5)
			FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
				;候補に残っているキャラのみを考慮
				IF CHECK_IS_FREE:(LOCAL:0)
					LOCAL:12 = MAX(ABL_POWER_X(ABL:(LOCAL:0):武闘, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:13
					LOCAL:22 = MAX(ABL_POWER_X(ABL:(LOCAL:0):知略, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:23
					LOCAL:32 = MAX(ABL_POWER_X(ABL:(LOCAL:0):妖術, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:33
					LOCAL:42 = (MAX(ABL_POWER_X(ABL:(LOCAL:0):歌唱, LOCAL:0) - ABL_50_POWER, 0) + 24000) / 24 - 1000
					LOCAL:52 = (MAX(ABL_POWER_X(ABL:(LOCAL:0):料理, LOCAL:0) - ABL_50_POWER, 0) + 24000) / 24 - 1000
					LOCAL:82 = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42 + LOCAL:52
					;部隊能力の上昇率が最大のキャラとその値を取得
					IF LOCAL:82 > LOCAL:80
						LOCAL:80 = LOCAL:82
						LOCAL:81 = LOCAL:0
					ENDIF
					IF TALENT:(LOCAL:0):外来人 && LOCAL:8
						LOCAL:81 = LOCAL:0
						BREAK
					ENDIF
				ENDIF
			NEXT

			UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2) = LOCAL:81

			IF UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2) >= 0
				;選んだキャラを候補から外す
				CHECK_IS_FREE:(UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2)) = 0
			ENDIF
		ENDIF
	NEXT
NEXT

;最後にNO順に並べ替える
FOR LOCAL:2, 0, 10
	FOR LOCAL:0, 0, 3
		IF UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0) >= 0
			FOR LOCAL:1, LOCAL:0 + 1, 3
				IF UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1) >= 0
					IF NO:(UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0)) > NO:(UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1))
						SWAP UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0), UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1)
					ENDIF
				ENDIF
			NEXT
		ENDIF
	NEXT
NEXT

;-------------------------------------------------
;都市ARG:0に最適な守将を配置。ARG:1を1にすると二人設定できる。
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@SET_CITY_COMMANDER_BEST(ARG:0, ARG:1 = 0)
#DIM LCOUNT
CALL CHECK_CITY_COMMANDER_BEST(ARG:0, ARG:1)
FOR LCOUNT:0, 0, MAX_CITY_COMMANDER
	CALL SET_CITY_COMMANDER(ARG:0, LCOUNT:0, CITY_COMMANDER_BEST:(LCOUNT:0))
NEXT
;-------------------------------------------------
;都市ARG:0に最適な守将を確認。ARG:1を1にすると二人設定できる。
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CHECK_CITY_COMMANDER_BEST(ARG:0, ARG:1 = 0)
#DIM 勢力
#DIM LCOUNT,2
#DIM 最大
VARSET LOCAL, __INT_MIN__
VARSET CITY_COMMANDER_BEST, -1
;都市を所有する勢力の番号を取得
勢力 = CITY_OWNER:(ARG:0)

;勢力に所属してFREEな各キャラの能力を記録
FOR LCOUNT, 0, CHARANUM
	IF CFLAG:(LCOUNT):所属 == 勢力 && TMP_IS_FREE:(LCOUNT):0 == 0
		;MASTER麾下の武将は、除外フラグをたてていたら除外する
		SIF 勢力 == CFLAG:MASTER:所属 && CFLAG:(LCOUNT):最強編成除外フラグ
			CONTINUE
		;知略の重みは武闘・妖術の1/8
		LOCAL:(LCOUNT) = MAX(ABL_POWER_X(ABL:(LCOUNT):武闘, LCOUNT) - ABL_50_POWER, 0) + MAX(ABL_POWER_X(MIN(ABL:(LCOUNT):知略, 110), LCOUNT) - ABL_50_POWER, 0) / 8 + MAX(ABL_POWER_X(ABL:(LCOUNT):妖術, LCOUNT) - ABL_50_POWER, 0)
	ENDIF
NEXT

;二人設定フラグが真なら2度回す
FOR LCOUNT:0, 0, 1 + (ARG:1 == 1)
	;LOCAL（記録した各キャラの能力）から、最大のものを探索
	最大 = MAXARRAY(LOCAL, 0)
	;最大のものが__INT_MIN__でなければ（その都市を所属している勢力に、IS_FREEなキャラが残っていれば）、そいつを登録
	IF 最大 != __INT_MIN__
		FOR LCOUNT:1, 0, CHARANUM
			IF LOCAL:(LCOUNT:1) == 最大
				CITY_COMMANDER_BEST:(LCOUNT:0) = LCOUNT:1
				LOCAL:(LCOUNT:1) = __INT_MIN__
				BREAK
			ENDIF
		NEXT
	ENDIF
NEXT