;-------------------------------------------------
;ARG:0勢力のAIの行動
;-------------------------------------------------
@AI_ACTION(ARG:0)

;ランダムキャラを使用している場合
IF FLAG:44
	;士官数が足りなければ士官を募集
	CALL RECRUIT_AI(ARG:0)
ENDIF

;国家間の隣接関係マップの作成(処理の高速化)
CALL TMP_CREATE_COUNTRY_NEIBORING_MAP

;{SLG_PP:0}期までは外交を行わない
IF DAY < SLG_PP:0
ELSE
	;外交の処理
	CALL AI_DIPLOMACY_ACT(ARG:0)
	;国家関係に変化があった場合
	IF RESULT
		;国家関係マップの再作成(処理の高速化)
		CALL TMP_CREATE_RELATION_MAP
	ENDIF
ENDIF

IF GET_OWN_CITY(ARG:0) > 0
	;部隊マップの作成(処理の高速化)
	CALL TMP_CREATE_UNIT_MAP
	;接続マップの作成
	CALL TMP_CREATE_CONNECTION_MAP(ARG:0)
	;リグル式AI
	CALL AI_ACO_ANT(ARG:0)
	CALL AI_ACO_PHEROMONE(ARG:0)
	
	;防衛を全て解除
	FOR LOCAL:0, 0, MAX_CITY
		IF CITY_OWNER:(LOCAL:0) == ARG:0
			;敵部隊のいる都市は解除不可
			IF !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
				COUNTRY_SOLDIER:(ARG:0) += CITY_SOLDIER:(LOCAL:0)
				CITY_SOLDIER:(LOCAL:0) = 0
				CITY_COMMANDER:(LOCAL:0) = 0
			ENDIF
		ENDIF
	NEXT
	FOR LOCAL:0, 0, 10
		;(LOCAL:0)番の部隊の存在判定　※最終決戦パッチ、FLAG:101の（勢力番号）ビットが1であればスキップ
		;最終決戦以外にも「野盗が中継点を占拠（つまりそこを通る旅人が陵辱される可能性もあるわけだ）」
		;「主人公勢力以外に複数勢力がある状態で特定勢力だけ決戦モード」に使えそうなので改造しました。
		IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0 && !GETBIT(FLAG:101, ARG:0)
			;ID=0の都市は未定義のはずなので解散させちゃう
			IF UNIT_POSITION:(ARG:0):(LOCAL:0) == 0
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;兵数500未満なら解散
			ELSEIF UNIT_SOLDIER:(ARG:0):(LOCAL:0) < 500
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;部隊の現在位置が地点かつ移動先を失っていれば解散する（強制解散フラグを使って時間を必要にするのも多分あり）
			ELSEIF !UNIT_TARGET:(ARG:0):(LOCAL:0) && CITY_TYPE:(UNIT_POSITION:(ARG:0):(LOCAL:0)) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;連合以上でも滞在できるようにする
			;同盟や連合を利用したり自国で隣接地の敵部隊と睨み合って欲しい
			;ただし、現在地か移動先が停戦対象なら解散
			ELSEIF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0))) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			ELSEIF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(UNIT_TARGET:(ARG:0):(LOCAL:0))) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			ELSE
				;連戦の影響がある場合
				IF CONFIG:313 > 0
					SIF RAND:(UNIT_TIRED_COUNT:(ARG:0):(LOCAL:0) / 3 + 1)
						CALL CLEAR_UNIT(ARG:0, LOCAL:0)
				ENDIF
				
				;現在位置に敵の部隊がいるときは解散させない
				IF IS_STAY_ENEMY_UNIT(UNIT_POSITION:(ARG:0):(LOCAL:0)) == 1
				;それ以外でまだ残っているなら一定確率で解散
				ELSEIF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0
					SIF !RAND:3
						CALL CLEAR_UNIT(ARG:0, LOCAL:0)
				ENDIF
			ENDIF
		ENDIF
	NEXT
	;DEBUGPRINTFORML %ANAME(GET_COUNTRY_BOSS(ARG:0))%
	;DEBUGPRINTFORML COUNTRY_SOLDIER:{COUNTRY_SOLDIER:(ARG:0)}
	;DEBUGPRINTFORML 最大:{GET_SUM_ECONOMY(ARG:0) / 10}

	CALL SLG_AI_SETDOCTRINE(ARG:0)
	CALL SLG_AI_RESCUE(ARG:0)
	
	IF DAY >= SLG_PP:1
		CALL AI_DEPLOY_ARMY(ARG:0, 0)
		
		;試用の結果あまりにも防御的なAIになることがわかった
		;・とりあえず連合時は現状の処理をそのまま使う（いい手が思いつかん）
		;・攻撃時は従来式AI
		;・所有領土が多いほど徐々に従来式AIを使用する確率が上がる（ただし少なすぎても拡大傾向）
		;・開幕直後は従来式
		;従来式AI
		IF GET_UNION_TARGET(ARG:0) > 0 || GROUPMATCH(COUNTRY_POLICY:(ARG:0), 1, 4, 7) || !INRANGE(RAND:(GET_OWN_CITY(ARG:0) + 1), 1, 3) || DAY <= SLG_PP:2
			FOR LOCAL:1, 0, 10
				CALL SLG_AI_INVASION_SETTARGET(ARG:0)
				SIF RESULT == 0
					BREAK
				CALL SLG_AI_INVASION_CREATEUNIT(ARG:0)
				SIF RESULT == 0
					BREAK
			NEXT
		;リグル式AI
		ELSE
			FOR LOCAL:1, 0, 10
				CALL SLG_AI_INVASION_CREATEUNIT(ARG:0)
				SIF RESULT == 0
					BREAK
			NEXT
			CALL AI_ACO_SETTARGET(ARG:0)
		ENDIF
		
		CALL AI_DEPLOY_ARMY(ARG:0, 1)
	ENDIF
	
	CALL SLG_AI_DEFENSE(ARG:0)
ENDIF

;-------------------------------------------------
;●防衛用の遊撃部隊を作成
;自軍の都市が攻撃を受けていれば防衛部隊を組織
;複数の都市が攻撃を受けている場合、都市を失った時に増加する戦線の数を基準に防衛の優先順位を決める
;-------------------------------------------------
;2016/05/13
;ver0.175バニラでのリグル式戦術AIパッチによるバグ修正
;・複数箇所を攻められた時に迎撃部隊が重要度関係なしに最もIDの若い都市に出現するような挙動になっていた
;・切り返しの判定に入った上でキャンセルになった場合、REVERSE_SOLDIERの補填処理が無かった
@SLG_AI_RESCUE(ARG:0)
;切り返し戦術の攻撃兵数
#DIM REVERSE_SOLDIER
;迎撃が必要な都市
#DIM KOUHO_COUNT            ;元はLOCAL:5
#DIM KOUHO_JUUYOU, MAX_CITY ;各候補地の重要性評価、元はLOCAL:200～
#DIM SAIJUUYOU              ;現時点での重要性の最高記録、元はLOCAL:6

;都市IDの一時保存用（迎撃候補→主要都市→反撃候補）
#DIM TEMP_ID, MAX_CITY      ;元はLOCAL:100～、LOCAL:300～、LOCAL:100～

#DIM JUUYOU_COUNT           ;特に重要な都市の数、元はLOCAL:7
#DIM GEIGEKI                ;実際に迎撃部隊の編成を行う場所、元はLOCAL:8, LOCAL:9

;敵部隊
#DIM ENEMY_COUNTRY          ;敵の勢力IDの一時保存用、元はLOCAL:1
#DIM ENEMY_UNIT             ;敵の部隊IDの一時保存用、元はLOCAL:2
#DIM ENEMY_TOTAL            ;迎撃都市に存在する敵の総数、元はLOCAL:3
#DIM UNIT_MAX               ;最も多かった敵の数、元はLOCAL:4
#DIM ENEMY_MAIN             ;主敵、UNIT_MAXの勢力主体、元はLOCAL:5

;切り返し
#DIM HANGEKI                ;反撃したかどうか、元はLOCAL:12
#DIM HANGEKI_COUNT          ;反撃できる都市（迎撃都市に隣接する主敵の都市）の数、元はLOCAL:2
#DIM HANGEKI_ID             ;決定した反撃対象都市、元はLOCAL:3
#DIM HANGEKI_ABLE           ;反撃できる（反撃都市に侵攻中の味方部隊がいない）かどうか、元はLOCAL:4

#DIM UNIT_PROTECT           ;防衛用に編成した部隊、元はLOCAL:10
#DIM UNIT_HANGEKI           ;反撃用に編成した部隊、元はLOCAL:11

IS_PROTECTED = 0

VARSET KOUHO_COUNT
VARSET TEMP_ID
VARSET KOUHO_JUUYOU
SAIJUUYOU = -999

FOR LOCAL:0, 0, MAX_CITY
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		;KOUHO_JUUYOU:KOUHO_COUNT = TMP_CHANGE_LINE_ONLOSE(LOCAL:0)
		;リグル式ではフェロモンで評価する
		KOUHO_JUUYOU:KOUHO_COUNT = PHEROMONE:(ARG:0):(LOCAL:0)
		IF KOUHO_JUUYOU:KOUHO_COUNT > SAIJUUYOU
			SAIJUUYOU = KOUHO_JUUYOU:KOUHO_COUNT
		ENDIF
		KOUHO_COUNT ++
		
	ENDIF
NEXT

VARSET JUUYOU_COUNT
VARSET TEMP_ID
FOR LOCAL:0, 0, KOUHO_COUNT
	IF KOUHO_JUUYOU:(LOCAL:0) == SAIJUUYOU
		TEMP_ID:JUUYOU_COUNT = LOCAL:0
		JUUYOU_COUNT ++
	ENDIF
NEXT

IF JUUYOU_COUNT > 0
	;空いている部隊の番号のうち最も若い番号を取得
	UNIT_PROTECT = -1
	FOR LOCAL:0, 0, 10
		IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
			UNIT_PROTECT = LOCAL:0
			BREAK
		ENDIF
	NEXT

	IF UNIT_PROTECT >= 0
		GEIGEKI = TEMP_ID:(RAND:(JUUYOU_COUNT))
		;元はLOCAL:(LOCAL:8 + 100)だったが
		;LOCAL:100～は優先順位が低いものも混じっている状態なのでLOCAL:300～が正しいはず？
		;じゃないと抽選にLOCAL:7を使用する意味がわからない
		;たぶんこれはバグだ
		;複数箇所を攻められた時に重要度関係なしに最もIDの若い都市に出現するような挙動になる

		UNIT_TARGET:(ARG:0):UNIT_PROTECT = 0
		UNIT_POSITION:(ARG:0):UNIT_PROTECT = GEIGEKI

		SELECTCASE CONFIG:300
		;簡単は全部隊の1/3を防衛に回す
		CASE 0
			UNIT_SOLDIER:(ARG:0):UNIT_PROTECT = COUNTRY_SOLDIER:(ARG:0) / 3
		;簡単以外は全部隊の2/3を防衛に回す
		CASEELSE
			UNIT_SOLDIER:(ARG:0):UNIT_PROTECT = COUNTRY_SOLDIER:(ARG:0) * 2 / 3
		ENDSELECT
		COUNTRY_SOLDIER:(ARG:0) -= UNIT_SOLDIER:(ARG:0):UNIT_PROTECT

		;守るべき都市上にいる敵兵の総数を調べる
		;このタイミングでLOCAL:1-5の内容は更新される
		ENEMY_TOTAL = 0
		UNIT_MAX = 0
		ENEMY_MAIN = 0
		
		;個人用メモ
		;TMP_UNIT_ONCITY_CNTとTMP_UNIT_ONCITY_NUMは各都市に駐留中の部隊のID情報
		;
		;TMP_UNIT_ONCITY_CNT:X:Y
		;X=駐留中の都市ID
		;Y=その都市の駐留部隊ID（0～19）
		;TMP_UNIT_ONCITY_NUMでもX,Yの意味するところは同一
		;
		;TMP_UNIT_ONCITY_CNT=勢力ID
		;TMP_UNIT_ONCITY_NUM=勢力内の部隊ID
		FOR LOCAL:0, 0, 20
			ENEMY_COUNTRY = TMP_UNIT_ONCITY_CNT:GEIGEKI:(LOCAL:0)
			ENEMY_UNIT = TMP_UNIT_ONCITY_NUM:GEIGEKI:(LOCAL:0)
			IF ENEMY_COUNTRY >= 1 && TMP_COUNTRY_RELATION:(ARG:0):ENEMY_COUNTRY == 0
				ENEMY_TOTAL += UNIT_SOLDIER:ENEMY_COUNTRY:ENEMY_UNIT
				IF UNIT_SOLDIER:ENEMY_COUNTRY:ENEMY_UNIT > UNIT_MAX
					UNIT_MAX = UNIT_SOLDIER:ENEMY_COUNTRY:ENEMY_UNIT
					ENEMY_MAIN = ENEMY_COUNTRY
				ENDIF
			ENDIF
		NEXT

		HANGEKI = 0
		REVERSE_SOLDIER = 0
		;難易度が困難以上で敵部隊が防衛部隊の1/3未満
		IF CONFIG:300 >= 2 && ENEMY_TOTAL * 3 < UNIT_SOLDIER:(ARG:0):(UNIT_PROTECT)
			;部隊の半数を攻撃に回す
			REVERSE_SOLDIER = UNIT_SOLDIER:(ARG:0):(UNIT_PROTECT) / 2
			UNIT_SOLDIER:(ARG:0):(UNIT_PROTECT) -= REVERSE_SOLDIER

			;出撃先の都市を選択
			;LOCAL:100～の更新
			;LOCAL:2 = 0
			VARSET TEMP_ID
			HANGEKI_COUNT = 0
			FOR LOCAL:0, 1, MAX_CITY
				IF CITY_OWNER:(LOCAL:0) == ENEMY_MAIN && IS_ROOT(GEIGEKI, LOCAL:0)
					TEMP_ID:HANGEKI_COUNT = LOCAL:0
					HANGEKI_COUNT ++
				ENDIF
			NEXT
			
			IF HANGEKI_COUNT > 0
				HANGEKI_ID = TEMP_ID:(RAND:(HANGEKI_COUNT))

				;既に相手国家に部隊を送り込んでいるなら切り返さない
				HANGEKI_ABLE = 1
				FOR LOCAL:0, 0, 10
					IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0 && CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0)) == HANGEKI_ID
						HANGEKI_ABLE = 0
						BREAK
					ENDIF
				NEXT

				IF HANGEKI_ABLE
					;空いている部隊の番号のうち最も若い番号を取得
					UNIT_HANGEKI = -1
					FOR LOCAL:0, 0, 10
						IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
							UNIT_HANGEKI = LOCAL:0
							BREAK
						ENDIF
					NEXT

					IF UNIT_HANGEKI >= 0
						;切り返し部隊を作成
						UNIT_SOLDIER:(ARG:0):UNIT_HANGEKI = REVERSE_SOLDIER
						UNIT_TARGET:(ARG:0):UNIT_HANGEKI = LOCAL:3
						UNIT_POSITION:(ARG:0):UNIT_HANGEKI = LOCAL:9

						;士官が行動可能な状態にあるかどうかのリストを作成
						CALL TMP_CREATE_IS_FREE_MAP

						;２部隊に載せる将を決定
						CALL CREATE_COMMANDER_LIST(ARG:0, 2)

						;防衛側の将を設定
						FOR LOCAL:0, 0, 3
							IF UNIT_COMMANDER_LIST:0:(LOCAL:0) >= 0
								CALL SET_UNIT_COMMANDER(ARG:0, UNIT_PROTECT, LOCAL:0, UNIT_COMMANDER_LIST:0:(LOCAL:0))
							ENDIF
						NEXT

						;侵攻側の将を設定
						FOR LOCAL:0, 0, 3
							IF UNIT_COMMANDER_LIST:1:(LOCAL:0) >= 0
								CALL SET_UNIT_COMMANDER(ARG:0, UNIT_HANGEKI, LOCAL:0, UNIT_COMMANDER_LIST:1:(LOCAL:0))
							ENDIF
						NEXT

						;防衛部隊を作成したことを示すフラグ
						IS_PROTECTED = 1

						HANGEKI = 1
					ENDIF
				ENDIF
			ENDIF
		ENDIF

		;切り返し戦術をとらなかった場合
		IF !HANGEKI
			;↑でREVERSE_SOLDIERを引いて反撃しなかった場合の補填処理が無かったのはバグっぽい
			UNIT_SOLDIER:(ARG:0):UNIT_PROTECT += REVERSE_SOLDIER
			
			;士官が行動可能な状態にあるかどうかのリストを作成
			CALL TMP_CREATE_IS_FREE_MAP

			;部隊が最強となるような士官の組み合わせを得る
			CALL CHECK_UNIT_COMMANDER_BEST(ARG:0)
			FOR LOCAL:0, 0, 3
				SIF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
					CALL SET_UNIT_COMMANDER(ARG:0, UNIT_PROTECT, LOCAL:0, UNIT_COMMANDER_BEST:(LOCAL:0))
			NEXT

			;防衛部隊を作成したことを示すフラグ
			IS_PROTECTED = 1
		ENDIF
	ENDIF
ENDIF


;-------------------------------------------------
;●防衛部隊の配分
;-------------------------------------------------
;2016/05/13
;ver0.175バニラでのリグル式戦術AIパッチによる改変
;ほぼ配分をフェロモンのみで評価するようにしただけ
@SLG_AI_DEFENSE(ARG:0)
#DIM CITY_COUNT               ;自勢力に所属する都市の総数
#DIM CITY_ID, MAX_CITY        ;自勢力都市のIDの一時記録
#DIM CITY_PHEROMONE, MAX_CITY ;自勢力都市のフェロモンの一時記録

SIF GET_OWN_CITY(ARG:0) < 1
	RETURN

VARSET CITY_COUNT
VARSET CITY_ID
VARSET CITY_PHEROMONE

;自勢力圏都市IDとフェロモン濃度の取得
FOR LOCAL, 0, MAX_CITY
	IF CITY_OWNER:(LOCAL:0) == ARG:0
		CITY_PHEROMONE:LOCAL = PHEROMONE:(ARG:0):LOCAL
		CITY_ID:CITY_COUNT = LOCAL:0
		CITY_COUNT ++
		SIF CITY_COUNT >= GET_OWN_CITY(ARG:0)
			BREAK
	ENDIF
NEXT

;ノームソートなるものをウィキペで見つけて試す
FOR LOCAL, 1, CITY_COUNT
	IF CITY_PHEROMONE:(CITY_ID:(LOCAL - 1)) < CITY_PHEROMONE:(CITY_ID:LOCAL)
		SWAP CITY_ID:(LOCAL - 1), CITY_ID:LOCAL
		LOCAL = MAX(LOCAL - 2, 0)
	ENDIF
NEXT

[IF_DEBUG]
	PRINTFORML ﾌｪﾛﾓﾝ
	FOR LOCAL, 0, CITY_COUNT
		PRINTFORML {CITY_ID:LOCAL, 3}%CITY_NAME_SHORT:(CITY_ID:LOCAL), 8%：{CITY_PHEROMONE:(CITY_ID:LOCAL)}
	NEXT
	WAIT
[ENDIF]


;初期防衛兵力0だとフェロモンも0で上手く動作しないので苦肉の策
SIF SUMARRAY(CITY_PHEROMONE) < 1
	GOTO FIRST_SET

SELECTCASE CONFIG:300
;簡単
CASE 0
	$FIRST_SET
	;残った兵力を防衛に回す
	LOCAL = COUNTRY_SOLDIER:(ARG:0) / CITY_COUNT
	
	;どの都市も等分配
	;重要度の高い都市から順に守将を決定
	FOR LOCAL:1, 0, CITY_COUNT
		CITY_SOLDIER:(CITY_ID:(LOCAL:1)) = LOCAL
		COUNTRY_SOLDIER:(ARG:0) -= LOCAL
		CALL TMP_CREATE_IS_FREE_MAP
		CALL SET_CITY_COMMANDER_BEST(CITY_ID:(LOCAL:1))
	NEXT
	;端数のつじつま合わせ
	IF COUNTRY_SOLDIER:(ARG:0) > 0
		CITY_SOLDIER:(CITY_ID:0) += COUNTRY_SOLDIER:(ARG:0)
		COUNTRY_SOLDIER:(ARG:0) = 0
	ENDIF

;普通
CASE 1
	;半分を均等に分配
	LOCAL = COUNTRY_SOLDIER:(ARG:0) / (CITY_COUNT * 2)
	FOR LOCAL:1, 0, CITY_COUNT
		CITY_SOLDIER:(CITY_ID:(LOCAL:1)) = LOCAL
		COUNTRY_SOLDIER:(ARG:0) -= LOCAL
	NEXT
	
	;フェロモン依存分配
	;重要度の高い都市から順に守将を決定
	FOR LOCAL:1, 0, CITY_COUNT
		LOCAL = COUNTRY_SOLDIER:(ARG:0) * CITY_PHEROMONE:(LOCAL:1) / SUMARRAY(CITY_PHEROMONE)
		CITY_SOLDIER:(CITY_ID:(LOCAL:1)) += LOCAL
		COUNTRY_SOLDIER:(ARG:0) -= LOCAL
		CALL TMP_CREATE_IS_FREE_MAP
		;防衛AIは武将の数に余裕があると二人配置する
		IF COUNTRY_AI_TYPE:(ARG:0) == AI_防衛
			IF TMP_GET_IS_FREE_NUM(ARG:0) >= CITY_COUNT + 1
				CALL SET_CITY_COMMANDER_BEST(CITY_ID:(LOCAL:1), 1)
			ELSE
				CALL SET_CITY_COMMANDER_BEST(CITY_ID:(LOCAL:1), 0)
			ENDIF
		ELSE
			CALL SET_CITY_COMMANDER_BEST(CITY_ID:(LOCAL:1), 0)
		ENDIF
	NEXT
	
	;端数のつじつま合わせ
	IF COUNTRY_SOLDIER:(ARG:0) > 0
		CITY_SOLDIER:(CITY_ID:0) += COUNTRY_SOLDIER:(ARG:0)
		COUNTRY_SOLDIER:(ARG:0) = 0
	ENDIF
	
;困難・虐め
CASEELSE
	;;全都市に各々500の兵を配分
	;FOR LOCAL:1, 0, CITY_COUNT
	;	CITY_SOLDIER:(CITY_ID:(LOCAL:1)) = MIN(500, COUNTRY_SOLDIER:(ARG:0))
	;	COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(CITY_ID:(LOCAL:1))
	;NEXT
	
	;1/2を均等に分配
	LOCAL = COUNTRY_SOLDIER:(ARG:0) / (CITY_COUNT * 2)
	FOR LOCAL:1, 0, CITY_COUNT
		CITY_SOLDIER:(CITY_ID:(LOCAL:1)) = LOCAL
		COUNTRY_SOLDIER:(ARG:0) -= LOCAL
	NEXT
	
	;フェロモン依存分配
	;重要度の高い都市から順に守将を決定
	FOR LOCAL:1, 0, CITY_COUNT
		LOCAL = COUNTRY_SOLDIER:(ARG:0) * CITY_PHEROMONE:(LOCAL:1) / SUMARRAY(CITY_PHEROMONE)
		CITY_SOLDIER:(CITY_ID:(LOCAL:1)) += LOCAL
		COUNTRY_SOLDIER:(ARG:0) -= LOCAL
		CALL TMP_CREATE_IS_FREE_MAP
		;全てのAIは武将の数に余裕があると二人配置する
		IF TMP_GET_IS_FREE_NUM(ARG:0) >= CITY_COUNT + 1
			CALL SET_CITY_COMMANDER_BEST(CITY_ID:(LOCAL:1), 1)
		ELSE
			CALL SET_CITY_COMMANDER_BEST(CITY_ID:(LOCAL:1), 0)
		ENDIF
	NEXT
	
	;端数のつじつま合わせ
	IF COUNTRY_SOLDIER:(ARG:0) > 0
		CITY_SOLDIER:(CITY_ID:0) += COUNTRY_SOLDIER:(ARG:0)
		COUNTRY_SOLDIER:(ARG:0) = 0
	ENDIF
ENDSELECT

;-------------------------------------------------
;作成可能な部隊のうち能力が最強となる将の組み合わせを調べる ARG:0=勢力番号 ARG:1 = 政治力によるフィルタを無視するフラグ
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CHECK_UNIT_COMMANDER_BEST(ARG:0, ARG:1 = 0)
;候補キャラのキャラ番号及びそのキャラの各パワーを記録する配列
;一次配列でそれぞれ用意しているのは配列検索系の関数を利用するため
#DIM CHECK_IS_FREE, 1000
#DIM FREE_STR, 1000
#DIM FREE_INT, 1000
#DIM FREE_MAG, 1000
#DIM FREE_POL, 1000
#DIM FREE_STAR, 1000
#DIM FREE_AI_PRIORITY, 4
;候補キャラのパワー上昇率と政治パワー合計
#DIM FREE_PUP, 1000
#DIM SUM_POL

VARSET CHECK_IS_FREE, -1
VARSET UNIT_COMMANDER_BEST, -1
VARSET LOCAL, -1
VARSET FREE_STR, -1
VARSET FREE_INT, -1
VARSET FREE_MAG, -1
VARSET FREE_POL, -1
VARSET FREE_PUP, -1
VARSET FREE_STAR, -1
VARSET FREE_AI_PRIORITY, 10

LOCAL:1 = 0
FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
	;自国の士官のみ考慮
	IF CFLAG:(LOCAL:0):1 == ARG:0 && TMP_IS_FREE:(LOCAL:0):0 == 0
		;MASTER麾下の武将は、除外フラグをたてていたら除外する
		SIF ARG:0 == CFLAG:MASTER:所属 && CFLAG:(LOCAL):最強編成除外フラグ
			CONTINUE
		;自由に行動可能なキャラ番号をCHECK_IS_FREEに順番に格納
		CHECK_IS_FREE:(LOCAL:1) = LOCAL:0
		LOCAL:1 ++
	ENDIF
NEXT

SUM_POL = 0


FOR LOCAL:0, 0, LOCAL:1
	;別変数に一旦格納
	LOCAL:2 = CHECK_IS_FREE:(LOCAL:0)
	FREE_STR:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):武闘, LOCAL:2)
	FREE_INT:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):知略, LOCAL:2)
	FREE_MAG:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):妖術, LOCAL:2)
	FREE_POL:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):政治, LOCAL:2)
	FREE_STAR:(LOCAL:0) = ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:2) * 10, LOCAL:2)
	;特殊勢力のキャラなら、各パワーを1にし、通常キャラが優先されるようにしておく。
	IF IS_SP_COUNTRY_CHARA(LOCAL:2)
		FREE_STR:(LOCAL:0) = 1
		FREE_INT:(LOCAL:0) = 1
		FREE_MAG:(LOCAL:0) = 1
		;政治パワーを非常に高くしておいて、通常キャラが政治パワーを理由に除外されないようにする
		FREE_POL:(LOCAL:0) *= 10
	ENDIF
	SUM_POL += FREE_POL:(LOCAL:0)
NEXT


IF !ARG:1
	FOR LOCAL:0, 0, LOCAL:1
		;行動可能なキャラの政治パワー合計のうち一定割合を占めているキャラを除外
		IF FREE_POL:(LOCAL:0) > AI_POLITICAL_LIMIT:(COUNTRY_AI_TYPE:(ARG:0)) * SUM_POL / 100
			FREE_STR:(LOCAL:0) = 0
			FREE_INT:(LOCAL:0) = 0
			FREE_MAG:(LOCAL:0) = 0
			FREE_STAR:(LOCAL:0) = 0
			FREE_POL:(LOCAL:0) = -1
		ENDIF
	NEXT
ENDIF

;武闘・知略・妖術の最大値を比較し最も大きい値を持つキャラを候補にする
LOCAL:10 = MAXARRAY(FREE_STR)
LOCAL:20 = MAXARRAY(FREE_INT)
LOCAL:30 = MAXARRAY(FREE_MAG)
LOCAL:40 = MAXARRAY(FREE_STAR)

;重視率のゆらぎ80～120%
FREE_AI_PRIORITY:0 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):0 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:1 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):1 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:2 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):2 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:3 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):3 * (80 + RAND:41) / 100

SIF ALLSAMES(LOCAL:10, LOCAL:20, LOCAL:30, LOCAL:40) && LOCAL:10 == -1
	RETURN 1
;AI毎に各パワーに重みをもたせて重視する能力を変化させている
;FREE_XXX及びCHECK_IS_FREEの配列は要素の位置が同じなら同じキャラのデータをとるのを利用
IF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:20 * FREE_AI_PRIORITY:1
	IF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:30 * FREE_AI_PRIORITY:2
		LOCAL:50 = FINDELEMENT(FREE_STR, LOCAL:10)
	ELSEIF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:40 * FREE_AI_PRIORITY:3
		LOCAL:50 = FINDELEMENT(FREE_STAR, LOCAL:40)
	ELSE
		LOCAL:50 = FINDELEMENT(FREE_MAG, LOCAL:30)
	ENDIF
ELSE
	IF LOCAL:20 * FREE_AI_PRIORITY:1 >= LOCAL:40 * FREE_AI_PRIORITY:3
		LOCAL:50 = FINDELEMENT(FREE_INT, LOCAL:20)
	ELSE
		LOCAL:50 = FINDELEMENT(FREE_STAR, LOCAL:40)
	ENDIF
ENDIF

UNIT_COMMANDER_BEST:0 = CHECK_IS_FREE:(LOCAL:50)

IF UNIT_COMMANDER_BEST:0 >= 0
	;１人目のキャラを候補から外す（政治パワーにフラグをつける）
	FREE_POL:(LOCAL:50) = -1

	;アップ率の合計が最も大きいキャラを次の候補にする
	LOCAL:40 = 0
	LOCAL:41 = -1
	FOR LOCAL:0, 0, LOCAL:1
		;候補に残っているキャラのみを考慮
		SIF FREE_POL:(LOCAL:0) < 0 || LOCAL:50 == LOCAL:0
			CONTINUE
		LOCAL:12 = MAX(FREE_STR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:0 / FREE_STR:(LOCAL:50)
		LOCAL:22 = MAX(FREE_INT:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:1 / FREE_INT:(LOCAL:50)
		LOCAL:32 = MAX(FREE_MAG:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:2 / FREE_MAG:(LOCAL:50)
		LOCAL:42 = MAX(FREE_STAR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:3 / FREE_STAR:(LOCAL:50)
		FREE_PUP:(LOCAL:0) = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42
	NEXT
	LOCAL:51 = FINDELEMENT(FREE_PUP,  MAX(MAXARRAY(FREE_PUP), 0))
	;２人目のキャラを記録し候補から外す
	UNIT_COMMANDER_BEST:1 = LOCAL:51 >= 0 ? CHECK_IS_FREE:(LOCAL:51) # -1
	IF UNIT_COMMANDER_BEST:1 >= 0
		FREE_POL:(LOCAL:51) = -1

		LOCAL:13 = FREE_STR:(LOCAL:50) + FREE_STR:(LOCAL:51)
		LOCAL:23 = FREE_INT:(LOCAL:50) + FREE_INT:(LOCAL:51)
		LOCAL:33 = FREE_MAG:(LOCAL:50) + FREE_MAG:(LOCAL:51)
		LOCAL:43 = FREE_STAR:(LOCAL:50) + FREE_STAR:(LOCAL:51)

	ENDIF

	VARSET FREE_PUP, -1

	;アップ率の合計が最も大きいキャラを次の候補にする(３人目は歌唱・料理も考慮、外来人とホフゴブ、野盗を優先)
	LOCAL:8 = 0
	IF LOCAL:50 < 0 || !IS_SP_COUNTRY_CHARA(CHECK_IS_FREE:(LOCAL:50))
		IF LOCAL:51 < 0 || !IS_SP_COUNTRY_CHARA(CHECK_IS_FREE:(LOCAL:51))
			LOCAL:8 = 1
		ENDIF
	ENDIF
	FOR LOCAL:0, 0, LOCAL:1
		;候補に残っているキャラのみを考慮
		SIF FREE_POL:(LOCAL:0) < 0 || GROUPMATCH(LOCAL:0, LOCAL:50, LOCAL:51)
			CONTINUE
		LOCAL:2 = CHECK_IS_FREE:(LOCAL:0)
		LOCAL:12 = MAX(FREE_STR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:13 * FREE_AI_PRIORITY:0
		LOCAL:22 = MAX(FREE_INT:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:23 * FREE_AI_PRIORITY:1
		LOCAL:32 = MAX(FREE_MAG:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:33 * FREE_AI_PRIORITY:2
		LOCAL:42 = MAX(FREE_STAR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:43 * FREE_AI_PRIORITY:3
		LOCAL:52 = (MAX(ABL_POWER_X(ABL:(LOCAL:2):歌唱, LOCAL:2) - ABL_50_POWER, 0) + 24000) / 24 - 1000
		LOCAL:62 = (MAX(ABL_POWER_X(ABL:(LOCAL:2):料理, LOCAL:2) - ABL_50_POWER, 0) + 24000) / 24 - 1000
		FREE_PUP:(LOCAL:0) = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42 + LOCAL:52

		IF IS_SP_COUNTRY_CHARA(CHECK_IS_FREE:(LOCAL:0)) && LOCAL:8
			FREE_PUP:(LOCAL:0) = __INT_MAX__
			BREAK
		ENDIF

	NEXT
	LOCAL:52 = FINDELEMENT(FREE_PUP, MAX(MAXARRAY(FREE_PUP), 0))

	;３人目のキャラを記録
	UNIT_COMMANDER_BEST:2 = LOCAL:52 >= 0 ? CHECK_IS_FREE:(LOCAL:52) # -1

	IF UNIT_COMMANDER_BEST:1 < 0 && UNIT_COMMANDER_BEST:2 >= 0
		UNIT_COMMANDER_BEST:1 = UNIT_COMMANDER_BEST:2
		UNIT_COMMANDER_BEST:2 = -1
	ENDIF
ELSE
;	DEBUGPRINTFORML {DAY, 3}【編成武将候補なし】:%NAME:(GET_COUNTRY_BOSS(ARG:0))%
	
ENDIF

;SIF !NOSAMES(LOCAL:50, LOCAL:51, LOCAL:52)
;	DEBUGPRINTFORML {DAY, 3}【武将重複？】:%NAME:(GET_COUNTRY_BOSS(ARG:0))%@ {LOCAL:50}:{CHECK_IS_FREE:(LOCAL:50)}, {LOCAL:51}:{CHECK_IS_FREE:(LOCAL:51)}, {LOCAL:52}:{CHECK_IS_FREE:(LOCAL:52)}

;最後にNO順に並べ替える
FOR LOCAL:0, 0, 3
	IF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
		FOR LOCAL:1, LOCAL:0 + 1, 3
			IF UNIT_COMMANDER_BEST:(LOCAL:1) >= 0
				IF NO:(UNIT_COMMANDER_BEST:(LOCAL:0)) > NO:(UNIT_COMMANDER_BEST:(LOCAL:1))
					SWAP UNIT_COMMANDER_BEST:(LOCAL:0), UNIT_COMMANDER_BEST:(LOCAL:1)
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

;-------------------------------------------------
;部隊に配置する将の組み合わせ候補のリストを作成 ARG:0=勢力番号 ARG:1=作成する部隊の数
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CREATE_COMMANDER_LIST(ARG:0, ARG:1)
;キャラが候補として残っているかどうかを記録する変数
#DIM CHECK_IS_FREE, 1000

VARSET CHECK_IS_FREE, 0

FOR LOCAL:0, 0, 10
	FOR LOCAL:1, 0, 3
		UNIT_COMMANDER_LIST:(LOCAL:0):(LOCAL:1) = -1
	NEXT
NEXT

FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
	;自国の士官のみ考慮
	IF CFLAG:(LOCAL:0):1 == ARG:0
		;自由に行動可能なら候補フラグを立てる
		CHECK_IS_FREE:(LOCAL:0) = (TMP_IS_FREE:(LOCAL:0):0 == 0)
	ENDIF
NEXT

FOR LOCAL:1, 0, ARG:1
	LOCAL:10 = ABL_50_POWER
	LOCAL:20 = ABL_50_POWER
	LOCAL:30 = 0
	LOCAL:40 = 0
	LOCAL:11 = -1
	LOCAL:21 = -1
	LOCAL:31 = -1
	FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
		;候補に残っているキャラのみを考慮
		IF CHECK_IS_FREE:(LOCAL:0)
			LOCAL:12 = ABL_POWER_X(ABL:(LOCAL:0):武闘, LOCAL:0)
			LOCAL:22 = ABL_POWER_X(ABL:(LOCAL:0):知略, LOCAL:0)
			LOCAL:32 = ABL_POWER_X(ABL:(LOCAL:0):妖術, LOCAL:0)
			LOCAL:42 = ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:0) * 10, LOCAL:0)
			;武闘パワーが最大のキャラとその値を取得
			IF LOCAL:12 > LOCAL:10
				LOCAL:10 = LOCAL:12
				LOCAL:11 = LOCAL:0
			ENDIF
			;知略パワーが最大のキャラとその値を取得
			IF LOCAL:22 > LOCAL:20
				LOCAL:20 = LOCAL:22
				LOCAL:21 = LOCAL:0
			ENDIF
			;妖術パワーが最大のキャラとその値を取得
			IF LOCAL:32 > LOCAL:30
				LOCAL:30 = LOCAL:32
				LOCAL:31 = LOCAL:0
			ENDIF
			IF LOCAL:42 > LOCAL:40
				LOCAL:40 = LOCAL:42
				LOCAL:41 = LOCAL:0
			ENDIF
		ENDIF
	NEXT

	;武闘最大値と知略最大値を比較し大きい方を持つキャラを１人目にする
	IF LOCAL:10 >= LOCAL:20
		IF LOCAL:10 >= LOCAL:30
			UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:11
		ELSE
			UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:31
		ENDIF
	ELSE
		UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:21
	ENDIF

	IF UNIT_COMMANDER_LIST:(LOCAL:1):0 >= 0
		;選んだキャラを候補から外す
		CHECK_IS_FREE:(UNIT_COMMANDER_LIST:(LOCAL:1):0) = 0
	ENDIF
NEXT

FOR LOCAL:2, 1, 3
	FOR LOCAL:1, 0, ARG:1
		;アップ率の合計が最も大きいキャラを２・３人目の候補にする(歌唱・料理も考慮)
		LOCAL:80 = 0
		LOCAL:81 = -1
		LOCAL:5 = UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2 - 1)
		LOCAL:6 = UNIT_COMMANDER_LIST:(LOCAL:1):0
		LOCAL:7 = UNIT_COMMANDER_LIST:(LOCAL:1):1
		LOCAL:8 = 0
		IF (LOCAL:6 < 0 || !IS_SP_COUNTRY_CHARA(LOCAL:6)) && (LOCAL:7 < 0 || !IS_SP_COUNTRY_CHARA(LOCAL:7))
			LOCAL:8 = 1
		ENDIF

		IF LOCAL:5 >= 0
			LOCAL:13 = ABL_POWER_X(ABL:(LOCAL:5):武闘, LOCAL:5)
			LOCAL:23 = ABL_POWER_X(ABL:(LOCAL:5):知略, LOCAL:5)
			LOCAL:33 = ABL_POWER_X(ABL:(LOCAL:5):妖術, LOCAL:5)
			LOCAL:43 = ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:5), LOCAL:5)
			FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
				;候補に残っているキャラのみを考慮
				IF CHECK_IS_FREE:(LOCAL:0)
					LOCAL:12 = MAX(ABL_POWER_X(ABL:(LOCAL:0):武闘, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:13
					LOCAL:22 = MAX(ABL_POWER_X(ABL:(LOCAL:0):知略, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:23
					LOCAL:32 = MAX(ABL_POWER_X(ABL:(LOCAL:0):妖術, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:33
					LOCAL:42 = MAX(ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:0), LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:43
					LOCAL:52 = (MAX(ABL_POWER_X(ABL:(LOCAL:0):歌唱, LOCAL:0) - ABL_50_POWER, 0) + 24000) / 24 - 1000
					LOCAL:62 = (MAX(ABL_POWER_X(ABL:(LOCAL:0):料理, LOCAL:0) - ABL_50_POWER, 0) + 24000) / 24 - 1000
					LOCAL:82 = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42 + LOCAL:52
					;部隊能力の上昇率が最大のキャラとその値を取得
					IF LOCAL:82 > LOCAL:80
						LOCAL:80 = LOCAL:82
						LOCAL:81 = LOCAL:0
					ENDIF
					IF IS_SP_COUNTRY_CHARA(LOCAL:0) && LOCAL:8
						LOCAL:81 = LOCAL:0
						BREAK
					ENDIF
				ENDIF
			NEXT

			UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2) = LOCAL:81

			IF UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2) >= 0
				;選んだキャラを候補から外す
				CHECK_IS_FREE:(UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2)) = 0
			ENDIF
		ENDIF
	NEXT
NEXT

;最後にNO順に並べ替える
FOR LOCAL:2, 0, 10
	FOR LOCAL:0, 0, 3
		IF UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0) >= 0
			FOR LOCAL:1, LOCAL:0 + 1, 3
				IF UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1) >= 0
					IF NO:(UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0)) > NO:(UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1))
						SWAP UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0), UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1)
					ENDIF
				ENDIF
			NEXT
		ENDIF
	NEXT
NEXT

;-------------------------------------------------
;都市ARG:0に最適な守将を配置。ARG:1を1にすると二人設定できる。
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@SET_CITY_COMMANDER_BEST(ARG:0, ARG:1 = 0)
#DIM LCOUNT
CALL CHECK_CITY_COMMANDER_BEST(ARG:0, ARG:1)
FOR LCOUNT:0, 0, MAX_CITY_COMMANDER
	CALL SET_CITY_COMMANDER(ARG:0, LCOUNT:0, CITY_COMMANDER_BEST:(LCOUNT:0))
NEXT
;-------------------------------------------------
;都市ARG:0に最適な守将を確認。ARG:1を1にすると二人設定できる。
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CHECK_CITY_COMMANDER_BEST(ARG:0, ARG:1 = 0)
#DIM 勢力
#DIM LCOUNT,2
#DIM 最大
VARSET LOCAL, __INT_MIN__
VARSET CITY_COMMANDER_BEST, -1
;都市を所有する勢力の番号を取得
勢力 = CITY_OWNER:(ARG:0)

;勢力に所属してFREEな各キャラの能力を記録
FOR LCOUNT, 0, CHARANUM
	IF CFLAG:(LCOUNT):所属 == 勢力 && TMP_IS_FREE:(LCOUNT):0 == 0
		;MASTER麾下の武将は、除外フラグをたてていたら除外する
		SIF 勢力 == CFLAG:MASTER:所属 && CFLAG:(LCOUNT):最強編成除外フラグ
			CONTINUE
		;知略の重みは武闘・妖術の1/8
{
		LOCAL:(LCOUNT) = MAX(ABL_POWER_X(ABL:(LCOUNT):武闘, LCOUNT) - ABL_50_POWER, 0) + MAX(ABL_POWER_X(MIN(ABL:(LCOUNT):知略, 110), LCOUNT) - ABL_50_POWER, 0) / 8 + MAX(ABL_POWER_X(ABL:(LCOUNT):妖術, LCOUNT) - ABL_50_POWER, 0) + 
						 MAX(ABL_POWER_X(ABL:(LCOUNT):料理, LCOUNT) - ABL_50_POWER, 0) / 8 + MAX(ABL_POWER_X(ABL:(LCOUNT):歌唱, LCOUNT) - ABL_50_POWER, 0) / 8 + 
						 MAX(ABL_POWER_X(TMP_CHARA_STARS:(LCOUNT) * 10, LCOUNT) - ABL_50_POWER, 0)
}
	ENDIF
NEXT

;二人設定フラグが真なら2度回す
FOR LCOUNT:0, 0, 1 + (ARG:1 == 1)
	;LOCAL（記録した各キャラの能力）から、最大のものを探索
	最大 = MAXARRAY(LOCAL, 0)
	;最大のものが__INT_MIN__でなければ（その都市を所属している勢力に、IS_FREEなキャラが残っていれば）、そいつを登録
	IF 最大 != __INT_MIN__
		FOR LCOUNT:1, 0, CHARANUM
			IF LOCAL:(LCOUNT:1) == 最大
				CITY_COMMANDER_BEST:(LCOUNT:0) = LCOUNT:1
				LOCAL:(LCOUNT:1) = __INT_MIN__
				BREAK
			ENDIF
		NEXT
	ENDIF
NEXT