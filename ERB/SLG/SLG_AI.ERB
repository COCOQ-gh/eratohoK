;-------------------------------------------------
;ARG:0勢力のAIの行動
;-------------------------------------------------
@AI_ACTION(ARG:0)
#DIM FIRST_LINE
FIRST_LINE = LINECOUNT

;ランダムキャラを使用している場合
IF FLAG:ランダムキャラ使用
	;士官数が足りなければ士官を募集
	CALL RECRUIT_AI(ARG:0)
ENDIF

;{SLG_PP:0}期までは外交を行わない
IF DAY < SLG_PP:0
ELSE
	;外交の処理
	CALL AI_DIPLOMACY_ACT(ARG:0)
	;国家関係に変化があった場合
	IF RESULT
		;国家関係マップの再作成(処理の高速化)
		CALL TMP_CREATE_RELATION_MAP
	ENDIF
ENDIF

IF GET_OWN_CITY(ARG:0) > 0
	;部隊マップの作成(処理の高速化)
	CALL TMP_CREATE_UNIT_MAP
	;リグル式AI
;	CALL AI_ACO_ANT(ARG:0)
;	CALL AI_ACO_PHEROMONE(ARG:0)

	
	;防衛を全て解除
	FOR LOCAL:0, 0, MAX_CITY
		IF CITY_OWNER:(LOCAL:0) == ARG:0
			;敵部隊のいる都市は解除不可
			IF !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
				COUNTRY_SOLDIER:(ARG:0) += CITY_SOLDIER:(LOCAL:0)
				CITY_SOLDIER:(LOCAL:0) = 0
				CITY_COMMANDER:(LOCAL:0) = 0
			ENDIF
		ENDIF
	NEXT
	
		FOR LOCAL:0, 0, 10
		;(LOCAL:0)番の部隊の解体判定　※最終決戦パッチ、FLAG:101の（勢力番号）ビットが1であればスキップ
		IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0 && !GETBIT(FLAG:101, ARG:0)
			;ID=0の都市は未定義のはずなので解散させちゃう
			IF UNIT_POSITION:(ARG:0):(LOCAL:0) == 0
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			ENDIF
			;現在位置に敵の部隊がいるときは解散させない
			IF IS_STAY_ENEMY_UNIT(UNIT_POSITION:(ARG:0):(LOCAL:0)) == 1
				CONTINUE
			;現在地か移動先が停戦対象なら解散
			ELSEIF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0))) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			ELSEIF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(UNIT_TARGET:(ARG:0):(LOCAL:0))) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;兵数2000ないし自国兵力の10%未満なら解散
			ELSEIF UNIT_SOLDIER:(ARG:0):(LOCAL:0) < MAX(GET_SUM_SOLDIER(ARG:0) / 10, 2000)
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;部隊の現在位置が中継地点かつ移動先を失っていれば解散する（強制解散フラグを使って時間を必要にするのも多分あり）
			ELSEIF !UNIT_TARGET:(ARG:0):(LOCAL:0) && CITY_TYPE:(UNIT_POSITION:(ARG:0):(LOCAL:0)) == 1
				CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			;部隊の所在地が敵対勢力でなければ解散する
			;部隊を使い回すようにしたのでナシ
			;ELSEIF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0))) >= 1
			;	CALL CLEAR_UNIT(ARG:0, LOCAL:0)
			ELSE
				;連戦の影響がある場合
				IF CONFIG:313 > 0
					SIF RAND:(UNIT_TIRED_COUNT:(ARG:0):(LOCAL:0) / 3 + 1)
						CALL CLEAR_UNIT(ARG:0, LOCAL:0)
				ENDIF
			ENDIF
		ENDIF
	NEXT
	
	;DEBUGPRINTFORML %ANAME(GET_COUNTRY_BOSS(ARG:0))%
	;DEBUGPRINTFORML COUNTRY_SOLDIER:{COUNTRY_SOLDIER:(ARG:0)}
	;DEBUGPRINTFORML 最大:{GET_SUM_ECONOMY(ARG:0) / 10}

	CALL SLG_AI_SETDOCTRINE(ARG:0)
	CALL SLG_AI_RESCUE(ARG:0)
	
	IF DAY >= SLG_PP:1
		CALL AI_DEPLOY_ARMY(ARG:0, 0)
		;既存部隊の攻撃目標設定
		FOR LOCAL:1, 0, 10
			SIF UNIT_SOLDIER:(ARG:0):(LOCAL:1) > 0  && UNIT_TARGET:(ARG:0):(LOCAL:1) <= 0
				CALL SLG_AI_INVASION_EXIST_UNIT_SETTARGET(ARG:0, LOCAL:1)
		NEXT
		;新規部隊の攻撃目標設定・作成処理
		FOR LOCAL:1, 0, 10
			CALL SLG_AI_INVASION_SETTARGET(ARG:0)
			SIF RESULT == 0
				BREAK
			CALL SLG_AI_INVASION_CREATEUNIT(ARG:0)
			SIF RESULT == 0
				BREAK
		NEXT
		;リグル式AI
;		ELSE
;			FOR LOCAL:1, 0, 10
;				CALL SLG_AI_INVASION_CREATEUNIT(ARG:0)
;				SIF RESULT == 0
;					BREAK
;			NEXT
;			CALL AI_ACO_SETTARGET(ARG:0)
;		ENDIF
		
		CALL AI_DEPLOY_ARMY(ARG:0, 1)
	ENDIF
	
	CALL SLG_AI_DEFENSE(ARG:0)
ENDIF

;クールタイム減少処理と、このターンに割り当てたフラグ削除処理
IF ARG:0 != CFLAG:MASTER:所属
	FOR LOCAL, 0, CHARANUM
		IF CFLAG:LOCAL:所属 == ARG:0
			COOLTIME:LOCAL:0 = MAX(COOLTIME:LOCAL:0 - 1 , 0)
			ASSIGNED_THIS_TURN:LOCAL:0 = 0
		ENDIF
	NEXT
ENDIF

;最初の行数と現在の行数が違う（ここにいたるまでに何か表示した）なら改行
SIF FIRST_LINE != LINECOUNT
	PRINTL

;-------------------------------------------------
;●防衛用の遊撃部隊を作成
;自軍の都市が攻撃を受けていれば防衛部隊を組織
;複数の都市が攻撃を受けている場合、都市を失った時に増加する戦線の数を基準に防衛の優先順位を決める
;-------------------------------------------------
;2016/05/13
;ver0.175バニラでのリグル式戦術AIパッチによるバグ修正
;・複数箇所を攻められた時に迎撃部隊が重要度関係なしに最もIDの若い都市に出現するような挙動になっていた
;・切り返しの判定に入った上でキャンセルになった場合、REVERSE_SOLDIERの補填処理が無かった
@SLG_AI_RESCUE(ARG:0)
;切り返し戦術の攻撃兵数
#DIM REVERSE_SOLDIER
;迎撃が必要な都市
#DIM KOUHO_COUNT            ;元はLOCAL:5
#DIM KOUHO_JUUYOU, MAX_CITY ;各候補地の重要性評価した都市ID
#DIM KOUHO_JUUYOU_VAL, MAX_CITY
#DIM SAIJUUYOU              ;現時点での重要性の最高記録、元はLOCAL:6

;都市IDの一時保存用（迎撃候補→主要都市→反撃候補）
#DIM TEMP_ID, MAX_CITY      ;元はLOCAL:100～、LOCAL:300～、LOCAL:100～

#DIM JUUYOU_COUNT           ;特に重要な都市の数、元はLOCAL:7
#DIM GEIGEKI                ;実際に迎撃部隊の編成を行う場所、元はLOCAL:8, LOCAL:9

;敵部隊
#DIM ENEMY_COUNTRY          ;敵の勢力IDの一時保存用、元はLOCAL:1
#DIM ENEMY_UNIT             ;敵の部隊IDの一時保存用、元はLOCAL:2
#DIM ENEMY_TOTAL            ;迎撃都市に存在する敵の総数、元はLOCAL:3
#DIM UNIT_MAX               ;最も多かった敵の数、元はLOCAL:4
#DIM ENEMY_MAIN             ;主敵、UNIT_MAXの勢力主体、元はLOCAL:5

;切り返し
#DIM HANGEKI                ;反撃したかどうか、元はLOCAL:12
#DIM HANGEKI_COUNT          ;反撃できる都市（迎撃都市に隣接する主敵の都市）の数、元はLOCAL:2
#DIM HANGEKI_ID             ;決定した反撃対象都市、元はLOCAL:3
#DIM HANGEKI_ABLE           ;反撃できる（反撃都市に侵攻中の味方部隊がいない）かどうか、元はLOCAL:4

#DIM UNIT_PROTECT           ;防衛用に編成した部隊、元はLOCAL:10
#DIM UNIT_HANGEKI           ;反撃用に編成した部隊、元はLOCAL:11

IS_PROTECTED = 0

VARSET KOUHO_COUNT
VARSET TEMP_ID
VARSET KOUHO_JUUYOU
VARSET KOUHO_JUUYOU_VAL
SAIJUUYOU = __INT_MIN__

FOR LOCAL:0, 1, MAX_CITY
	IF (CITY_OWNER:(LOCAL:0) == ARG:0 && TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)) || (IS_COUNTRY(CITY_OWNER:(LOCAL:0)) && GROUPMATCH(TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:1), 2, 3, 4) && TMP_IS_STAY_ENEMY_UNIT(LOCAL:0))
		;KOUHO_JUUYOU:KOUHO_COUNT = TMP_CHANGE_LINE_ONLOSE(LOCAL:0)
		;リグル式ではフェロモンで評価する
		;他国を防衛する仕様にしたかったのでフェロモンとりやめ　経済値＋(防衛値の50倍) で評価する
		;ただしその都市を含む飛び地が、その勢力にとって最大の飛び地でない場合、最大の飛び地とのサイズ比に応じて評価値が下がる
		KOUHO_JUUYOU_VAL:KOUHO_COUNT = CITY_ECONOMY:(LOCAL) + CITY_GUARD:(LOCAL) * 50
		KOUHO_JUUYOU_VAL:KOUHO_COUNT = KOUHO_JUUYOU_VAL:KOUHO_COUNT * TMP_ENCLAVE_SIZE:(ARG:0):LOCAL / TMP_MAX_ENCLAVE_SIZE:(ARG:0)
		KOUHO_JUUYOU:KOUHO_COUNT = LOCAL
		KOUHO_COUNT ++
	ENDIF
NEXT

SIF KOUHO_COUNT == 0
	RETURN

SAIJUUYOU = MAXARRAY(KOUHO_JUUYOU_VAL)

VARSET JUUYOU_COUNT
VARSET TEMP_ID
WHILE JUUYOU_COUNT <= MIN(2, KOUHO_COUNT - 1)
	LOCAL:0 = FINDELEMENT(KOUHO_JUUYOU_VAL, SAIJUUYOU)
	TEMP_ID:JUUYOU_COUNT = KOUHO_JUUYOU:(LOCAL:0)
	JUUYOU_COUNT ++
	KOUHO_JUUYOU_VAL:(LOCAL:0) = __INT_MIN__
	SAIJUUYOU = MAXARRAY(KOUHO_JUUYOU_VAL)
WEND

;何してんのコレ？
;後ろでRANDとか使ってるわりに一個しか取れてない
;なんかおかしいので上のやつで代替
;FOR LOCAL:0, 0, KOUHO_COUNT
;	IF KOUHO_JUUYOU:(LOCAL:0) == SAIJUUYOU
;		TEMP_ID:JUUYOU_COUNT = LOCAL:0
;		JUUYOU_COUNT ++
;	ENDIF
;NEXT

IF JUUYOU_COUNT > 0
	;空いている部隊の番号のうち最も若い番号を取得
	UNIT_PROTECT = -1
	FOR LOCAL:0, 0, 10
		IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
			UNIT_PROTECT = LOCAL:0
			BREAK
		ENDIF
	NEXT

	IF UNIT_PROTECT >= 0
		GEIGEKI = TEMP_ID:(RAND:(JUUYOU_COUNT))
		;元はLOCAL:(LOCAL:8 + 100)だったが
		;LOCAL:100～は優先順位が低いものも混じっている状態なのでLOCAL:300～が正しいはず？
		;じゃないと抽選にLOCAL:7を使用する意味がわからない
		;たぶんこれはバグだ
		;複数箇所を攻められた時に重要度関係なしに最もIDの若い都市に出現するような挙動になる

		UNIT_TARGET:(ARG:0):UNIT_PROTECT = 0
		UNIT_POSITION:(ARG:0):UNIT_PROTECT = GEIGEKI
		SELECTCASE CONFIG:300
		;簡単は全部隊の1/3を防衛に回す
		CASE 0
			UNIT_SOLDIER:(ARG:0):UNIT_PROTECT = COUNTRY_SOLDIER:(ARG:0) / 3
		;簡単以外は全部隊の2/3を防衛に回す
		CASEELSE
			UNIT_SOLDIER:(ARG:0):UNIT_PROTECT = COUNTRY_SOLDIER:(ARG:0) * 2 / 3
		ENDSELECT
		COUNTRY_SOLDIER:(ARG:0) -= UNIT_SOLDIER:(ARG:0):UNIT_PROTECT

		;守るべき都市上にいる敵兵の総数を調べる
		;このタイミングでLOCAL:1-5の内容は更新される
		ENEMY_TOTAL = 0
		UNIT_MAX = 0
		ENEMY_MAIN = 0
		
		;個人用メモ
		;TMP_UNIT_ONCITY_CNTとTMP_UNIT_ONCITY_NUMは各都市に駐留中の部隊のID情報
		;
		;TMP_UNIT_ONCITY_CNT:X:Y
		;X=駐留中の都市ID
		;Y=その都市の駐留部隊ID（0～19）
		;TMP_UNIT_ONCITY_NUMでもX,Yの意味するところは同一
		;
		;TMP_UNIT_ONCITY_CNT=勢力ID
		;TMP_UNIT_ONCITY_NUM=勢力内の部隊ID
		FOR LOCAL:0, 0, 20
			ENEMY_COUNTRY = TMP_UNIT_ONCITY_CNT:GEIGEKI:(LOCAL:0)
			ENEMY_UNIT = TMP_UNIT_ONCITY_NUM:GEIGEKI:(LOCAL:0)
			IF ENEMY_COUNTRY >= 1 && TMP_COUNTRY_RELATION:(ARG:0):ENEMY_COUNTRY == 0
				ENEMY_TOTAL += UNIT_SOLDIER:ENEMY_COUNTRY:ENEMY_UNIT
				IF UNIT_SOLDIER:ENEMY_COUNTRY:ENEMY_UNIT > UNIT_MAX
					UNIT_MAX = UNIT_SOLDIER:ENEMY_COUNTRY:ENEMY_UNIT
					ENEMY_MAIN = ENEMY_COUNTRY
				ENDIF
			ENDIF
		NEXT

		HANGEKI = 0
		REVERSE_SOLDIER = 0
		;難易度が困難以上で敵部隊が防衛部隊の1/3未満
		IF CONFIG:300 >= 2 && ENEMY_TOTAL * 3 < UNIT_SOLDIER:(ARG:0):(UNIT_PROTECT)
			;部隊の半数を攻撃に回す
			REVERSE_SOLDIER = UNIT_SOLDIER:(ARG:0):(UNIT_PROTECT) / 2
			UNIT_SOLDIER:(ARG:0):(UNIT_PROTECT) -= REVERSE_SOLDIER

			;出撃先の都市を選択
			;LOCAL:100～の更新
			;LOCAL:2 = 0
			VARSET TEMP_ID
			HANGEKI_COUNT = 0
			FOR LOCAL:0, 1, MAX_CITY
				IF CITY_OWNER:(LOCAL:0) == ENEMY_MAIN && IS_ROOT(GEIGEKI, LOCAL:0)
					TEMP_ID:HANGEKI_COUNT = LOCAL:0
					HANGEKI_COUNT ++
				ENDIF
			NEXT
			
			IF HANGEKI_COUNT > 0
				HANGEKI_ID = TEMP_ID:(RAND:(HANGEKI_COUNT))

				;既に相手国家に部隊を送り込んでいるなら切り返さない
				HANGEKI_ABLE = 1
				FOR LOCAL:0, 0, 10
					IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) > 0 && CITY_OWNER:(UNIT_POSITION:(ARG:0):(LOCAL:0)) == HANGEKI_ID
						HANGEKI_ABLE = 0
						BREAK
					ENDIF
				NEXT

				IF HANGEKI_ABLE
					;空いている部隊の番号のうち最も若い番号を取得
					UNIT_HANGEKI = -1
					FOR LOCAL:0, 0, 10
						IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
							UNIT_HANGEKI = LOCAL:0
							BREAK
						ENDIF
					NEXT

					IF UNIT_HANGEKI >= 0
						;切り返し部隊を作成
						UNIT_SOLDIER:(ARG:0):UNIT_HANGEKI = REVERSE_SOLDIER
						UNIT_TARGET:(ARG:0):UNIT_HANGEKI = LOCAL:3
						UNIT_POSITION:(ARG:0):UNIT_HANGEKI = LOCAL:9

						;士官が行動可能な状態にあるかどうかのリストを作成
						CALL TMP_CREATE_IS_FREE_MAP

						;２部隊に載せる将を決定
						CALL CREATE_COMMANDER_LIST(ARG:0, 2)

						;防衛側の将を設定
						FOR LOCAL:0, 0, 3
							IF UNIT_COMMANDER_LIST:0:(LOCAL:0) >= 0
								CALL SET_UNIT_COMMANDER(ARG:0, UNIT_PROTECT, LOCAL:0, UNIT_COMMANDER_LIST:0:(LOCAL:0))
							ENDIF
						NEXT

						;侵攻側の将を設定
						FOR LOCAL:0, 0, 3
							IF UNIT_COMMANDER_LIST:1:(LOCAL:0) >= 0
								CALL SET_UNIT_COMMANDER(ARG:0, UNIT_HANGEKI, LOCAL:0, UNIT_COMMANDER_LIST:1:(LOCAL:0))
							ENDIF
						NEXT

						;防衛部隊を作成したことを示すフラグ
						IS_PROTECTED = 1

						HANGEKI = 1
					ENDIF
				ENDIF
			ENDIF
		ENDIF

		;切り返し戦術をとらなかった場合
		IF !HANGEKI
			;↑でREVERSE_SOLDIERを引いて反撃しなかった場合の補填処理が無かったのはバグっぽい
			UNIT_SOLDIER:(ARG:0):UNIT_PROTECT += REVERSE_SOLDIER
			
			;士官が行動可能な状態にあるかどうかのリストを作成
			CALL TMP_CREATE_IS_FREE_MAP

			;部隊が最強となるような士官の組み合わせを得る
			CALL CHECK_UNIT_COMMANDER_BEST(ARG:0)
			FOR LOCAL:0, 0, 3
				SIF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
					CALL SET_UNIT_COMMANDER(ARG:0, UNIT_PROTECT, LOCAL:0, UNIT_COMMANDER_BEST:(LOCAL:0))
			NEXT

			;防衛部隊を作成したことを示すフラグ
			IS_PROTECTED = 1
		ENDIF
	ENDIF
ENDIF


;-------------------------------------------------
;●防衛部隊の配分
;-------------------------------------------------
;2016/05/13
;ver0.175バニラでのリグル式戦術AIパッチによる改変
;ほぼ配分をフェロモンのみで評価するようにしただけ
;2016/06/08
;上記を差し戻し
@SLG_AI_DEFENSE(ARG:0)
VARSET LOCAL
;敵勢力の都市と隣接する都市の探索
LOCAL:5 = 0
FOR LOCAL:0, 0, MAX_CITY
	;ARG:0勢力の都市で、敵部隊と交戦中でない
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		FOR LOCAL:1, 0, MAX_CITY
			;敵勢力の都市と隣接しているかをチェック
			IF CITY_OWNER:(LOCAL:1) != 0 && CITY_TYPE:(LOCAL:1) == 0 && IS_ROOT(LOCAL:0, LOCAL:1)
				IF TMP_COUNTRY_RELATION:(CITY_OWNER:(LOCAL:0)):(CITY_OWNER:(LOCAL:1)) == 0
					;敵勢力の都市と隣接する都市の番号をLOCAL:100～に順次記録していく
					LOCAL:(LOCAL:5 + 100) = LOCAL:0
					LOCAL:5 ++
					BREAK
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

;敵勢力からの距離が２の都市の探索(「敵都市に隣接する都市」に隣接)
LOCAL:6 = 0
FOR LOCAL:0, 0, MAX_CITY
	;ARG:0勢力の都市で、敵部隊と交戦中でない
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		;「敵都市に隣接する都市」として既に記録されているかをチェック
		LOCAL:9 = 1
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 100)
			IF LOCAL:0 == LOCAL:2
				LOCAL:9 = 0
				BREAK
			ENDIF
		NEXT

		;敵都市に隣接していない場合
		IF LOCAL:9
			FOR LOCAL:1, 0, LOCAL:5
				LOCAL:2 = LOCAL:(LOCAL:1 + 100)
				;「敵都市に隣接する都市」に隣接しているかをチェック
				IF IS_ROOT(LOCAL:0, LOCAL:2)
					;敵勢力からの距離が２の都市の番号をLOCAL:200～に順次記録していく
					LOCAL:(LOCAL:6 + 200) = LOCAL:0
					LOCAL:6 ++
					BREAK
				ENDIF
			NEXT
		ENDIF
	ENDIF
NEXT

;敵勢力からの距離が３以上の都市の探索(残りの都市)
LOCAL:7 = 0
FOR LOCAL:0, 0, MAX_CITY
	;ARG:0勢力の都市で、敵部隊と交戦中でない
	IF CITY_OWNER:(LOCAL:0) == ARG:0 && !TMP_IS_STAY_ENEMY_UNIT(LOCAL:0)
		;「敵都市に隣接する都市」として既に記録されているかをチェック
		LOCAL:8 = 1
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 100)
			IF LOCAL:0 == LOCAL:2
				LOCAL:8 = 0
				BREAK
			ENDIF
		NEXT

		IF LOCAL:8
			;「敵都市に隣接する都市」として既に記録されているかをチェック
			LOCAL:9 = 1
			FOR LOCAL:1, 0, LOCAL:6
				LOCAL:2 = LOCAL:(LOCAL:1 + 200)
				IF LOCAL:0 == LOCAL:2
					LOCAL:9 = 0
					BREAK
				ENDIF
			NEXT

			;どちらのリストにも記録されていない場合
			IF LOCAL:9
				;敵勢力からの距離が３以上の都市の番号をLOCAL:300～に順次記録していく
				LOCAL:(LOCAL:7 + 300) = LOCAL:0
				LOCAL:7 ++
			ENDIF
		ENDIF
	ENDIF
NEXT

;敵勢力に隣接する都市に重要度を付ける
LOCAL:10 = 0
FOR LOCAL:0, 0, LOCAL:5
	LOCAL:2 = LOCAL:(LOCAL:0 + 100)
	LOCAL:(LOCAL:0 + 400) = 100
	;占領されたときに増える戦線の数が多いほど重要
	LOCAL:(LOCAL:0 + 400) += MAX(TMP_CHANGE_LINE_ONLOSE(ARG:0, LOCAL:2), -1) * 30
	;勢力全体に占める経済規模の割合が高いほど重要
	LOCAL:(LOCAL:0 + 400) += CITY_ECONOMY:(LOCAL:2) * 100 / GET_SUM_ECONOMY(ARG:0)
	;飛び地サイズの比
	LOCAL:(LOCAL:0 + 400) = LOCAL:(LOCAL:0 + 400) * TMP_ENCLAVE_SIZE:(ARG:0):(LOCAL:2) / TMP_MAX_ENCLAVE_SIZE:(ARG:0)
	LOCAL:10 += LOCAL:(LOCAL:0 + 400)
NEXT

SELECTCASE CONFIG:300
;簡単
CASE 0
	;残った兵力を防衛に回す
	LOCAL:2 = COUNTRY_SOLDIER:(ARG:0) / (MAX(1, LOCAL:5 + LOCAL:6 + LOCAL:7))

	;どの都市も等分配
	FOR LOCAL:0, 0, LOCAL:5
		LOCAL:1 = LOCAL:(LOCAL:0 + 100)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	FOR LOCAL:0, 0, LOCAL:6
		LOCAL:1 = LOCAL:(LOCAL:0 + 200)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	FOR LOCAL:0, 0, LOCAL:7
		LOCAL:1 = LOCAL:(LOCAL:0 + 300)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	;重要度の高い都市から順に守将を決定
	LOCAL:15 = LOCAL:5
	FOR LOCAL:0, 0, LOCAL:15
		LOCAL:16 = 0
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 400)
			IF LOCAL:2 > LOCAL:16
				LOCAL:16 = LOCAL:2
				LOCAL:17 = LOCAL:1
			ENDIF
		NEXT
		CALL TMP_CREATE_IS_FREE_MAP
		CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100))
		FOR LOCAL:1, LOCAL:17, LOCAL:5
			LOCAL:(LOCAL:1 + 100) = LOCAL:(LOCAL:1 + 101)
			LOCAL:(LOCAL:1 + 400) = LOCAL:(LOCAL:1 + 401)
		NEXT
		LOCAL:5 --
	NEXT
;普通
CASE 1
	;残った兵力を防衛に回す
	LOCAL:2 = COUNTRY_SOLDIER:(ARG:0) / (MAX(1, LOCAL:5 * 2 + LOCAL:6 + LOCAL:7))

	;敵勢力と隣接する都市への割り振り
	FOR LOCAL:0, 0, LOCAL:5
		LOCAL:1 = LOCAL:(LOCAL:0 + 100)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2 * 2 * LOCAL:(LOCAL:0 + 400) * LOCAL:5 / LOCAL:10
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;敵勢力からの距離が２、３の都市への割り振り
	FOR LOCAL:0, 0, LOCAL:6
		LOCAL:1 = LOCAL:(LOCAL:0 + 200)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	FOR LOCAL:0, 0, LOCAL:7
		LOCAL:1 = LOCAL:(LOCAL:0 + 300)
		CITY_SOLDIER:(LOCAL:1) = LOCAL:2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT
	;重要度の高い都市から順に守将を決定
	LOCAL:15 = LOCAL:5
	FOR LOCAL:0, 0, LOCAL:15
		LOCAL:16 = 0
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 400)
			IF LOCAL:2 > LOCAL:16
				LOCAL:16 = LOCAL:2
				LOCAL:17 = LOCAL:1
			ENDIF
		NEXT
		CALL TMP_CREATE_IS_FREE_MAP
		;防衛AIは武将の数に余裕があると二人配置する
		IF COUNTRY_AI_TYPE:(ARG:0) == AI_防衛
			IF TMP_GET_IS_FREE_NUM(ARG:0) >= LOCAL:5 + 1
				CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 1)
			ELSE
				CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 0)
			ENDIF
		ELSE
			CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 0)
		ENDIF
		FOR LOCAL:1, LOCAL:17, LOCAL:5
			LOCAL:(LOCAL:1 + 100) = LOCAL:(LOCAL:1 + 101)
			LOCAL:(LOCAL:1 + 400) = LOCAL:(LOCAL:1 + 401)
		NEXT
		LOCAL:5 --
	NEXT

;困難・虐め
CASEELSE
	;距離３以上の都市に各々500の兵を配分
	FOR LOCAL:0, 0, LOCAL:7
		LOCAL:1 = LOCAL:(LOCAL:0 + 300)
		CITY_SOLDIER:(LOCAL:1) = MIN(500, COUNTRY_SOLDIER:(ARG:0))
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;残った兵力を防衛に回す
	LOCAL:2 = COUNTRY_SOLDIER:(ARG:0) / (MAX(1, LOCAL:5 * 5 + LOCAL:6 * 2))

	;敵勢力と隣接する都市への割り振り
	FOR LOCAL:0, 0, LOCAL:5
		LOCAL:1 = LOCAL:(LOCAL:0 + 100)
		CITY_SOLDIER:(LOCAL:1) += LOCAL:2 * 5 * LOCAL:(LOCAL:0 + 400) * LOCAL:5 / LOCAL:10
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;敵勢力からの距離が２の都市への割り振り
	FOR LOCAL:0, 0, LOCAL:6
		LOCAL:1 = LOCAL:(LOCAL:0 + 200)
		CITY_SOLDIER:(LOCAL:1) += LOCAL:2 * 2
		COUNTRY_SOLDIER:(ARG:0) -= CITY_SOLDIER:(LOCAL:1)
	NEXT

	;重要度の高い都市から順に守将を決定
	LOCAL:15 = LOCAL:5
	FOR LOCAL:0, 0, LOCAL:15
		LOCAL:16 = 0
		FOR LOCAL:1, 0, LOCAL:5
			LOCAL:2 = LOCAL:(LOCAL:1 + 400)
			IF LOCAL:2 > LOCAL:16
				LOCAL:16 = LOCAL:2
				LOCAL:17 = LOCAL:1
			ENDIF
		NEXT
		CALL TMP_CREATE_IS_FREE_MAP
		;全てのAIは武将の数に余裕があると二人配置する
		IF TMP_GET_IS_FREE_NUM(ARG:0) >= LOCAL:5 + 1
			CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 1)
		ELSE
			CALL SET_CITY_COMMANDER_BEST(LOCAL:(LOCAL:17 + 100), 0)
		ENDIF
		FOR LOCAL:1, LOCAL:17, LOCAL:5
			LOCAL:(LOCAL:1 + 100) = LOCAL:(LOCAL:1 + 101)
			LOCAL:(LOCAL:1 + 400) = LOCAL:(LOCAL:1 + 401)
		NEXT
		LOCAL:5 --
	NEXT
ENDSELECT
;-------------------------------------------------
;作成可能な部隊のうち能力が最強となる将の組み合わせを調べる ARG:0=勢力番号 ARG:1 = 政治力によるフィルタを無視するフラグ
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CHECK_UNIT_COMMANDER_BEST(ARG:0, ARG:1 = 0)
;候補キャラのキャラ番号及びそのキャラの各パワーを記録する配列
;一次配列でそれぞれ用意しているのは配列検索系の関数を利用するため
#DIM CHECK_IS_FREE, 1000
#DIM FREE_STR, 1000
#DIM FREE_INT, 1000
#DIM FREE_MAG, 1000
#DIM FREE_POL, 1000
#DIM FREE_STAR, 1000
#DIM FREE_AI_PRIORITY, 4
;候補キャラのパワー上昇率と政治パワー合計
#DIM FREE_PUP, 1000
#DIM SUM_POL

VARSET CHECK_IS_FREE, -1
VARSET UNIT_COMMANDER_BEST, -1
VARSET LOCAL, -1
VARSET FREE_STR, -1
VARSET FREE_INT, -1
VARSET FREE_MAG, -1
VARSET FREE_POL, -1
VARSET FREE_PUP, -1
VARSET FREE_STAR, -1
VARSET FREE_AI_PRIORITY, 10

LOCAL:1 = 0
FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
	;自国の士官のみ考慮
	IF CFLAG:(LOCAL:0):1 == ARG:0 && TMP_IS_FREE:(LOCAL:0):0 == 0
		;MASTER麾下の武将は、除外フラグをたてていたら除外する
		SIF ARG:0 == CFLAG:MASTER:所属 && CFLAG:(LOCAL):最強編成除外フラグ
			CONTINUE
		;自由に行動可能なキャラ番号をCHECK_IS_FREEに順番に格納
		CHECK_IS_FREE:(LOCAL:1) = LOCAL:0
		LOCAL:1 ++
	ENDIF
NEXT

SUM_POL = 0


FOR LOCAL:0, 0, LOCAL:1
	;別変数に一旦格納
	LOCAL:2 = CHECK_IS_FREE:(LOCAL:0)
	FREE_STR:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):武闘, LOCAL:2)
	FREE_INT:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):知略, LOCAL:2)
	FREE_MAG:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):妖術, LOCAL:2)
	FREE_POL:(LOCAL:0) = ABL_POWER_X(ABL:(LOCAL:2):政治, LOCAL:2)
	FREE_STAR:(LOCAL:0) = ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:2) * 10, LOCAL:2)
	;特殊勢力のキャラなら、各パワーを1にし、通常キャラが優先されるようにしておく。
	IF IS_SP_COUNTRY_CHARA(LOCAL:2)
		FREE_STR:(LOCAL:0) = 1
		FREE_INT:(LOCAL:0) = 1
		FREE_MAG:(LOCAL:0) = 1
		;政治パワーを非常に高くしておいて、通常キャラが政治パワーを理由に除外されないようにする
		FREE_POL:(LOCAL:0) *= 10
	ENDIF
	SUM_POL += FREE_POL:(LOCAL:0)
NEXT


IF !ARG:1
	FOR LOCAL:0, 0, LOCAL:1
		;行動可能なキャラの政治パワー合計のうち一定割合を占めているキャラを除外
		IF FREE_POL:(LOCAL:0) > AI_POLITICAL_LIMIT:(COUNTRY_AI_TYPE:(ARG:0)) * SUM_POL / 100
			FREE_STR:(LOCAL:0) = 0
			FREE_INT:(LOCAL:0) = 0
			FREE_MAG:(LOCAL:0) = 0
			FREE_STAR:(LOCAL:0) = 0
			FREE_POL:(LOCAL:0) = -1
		ENDIF
	NEXT
ENDIF

;武闘・知略・妖術の最大値を比較し最も大きい値を持つキャラを候補にする
LOCAL:10 = MAXARRAY(FREE_STR)
LOCAL:20 = MAXARRAY(FREE_INT)
LOCAL:30 = MAXARRAY(FREE_MAG)
LOCAL:40 = MAXARRAY(FREE_STAR)

;重視率のゆらぎ80～120%
FREE_AI_PRIORITY:0 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):0 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:1 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):1 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:2 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):2 * (80 + RAND:41) / 100
FREE_AI_PRIORITY:3 = AI_PRIORITY:(COUNTRY_AI_TYPE:(ARG:0)):3 * (80 + RAND:41) / 100

SIF ALLSAMES(LOCAL:10, LOCAL:20, LOCAL:30, LOCAL:40) && LOCAL:10 == -1
	RETURN 1
;AI毎に各パワーに重みをもたせて重視する能力を変化させている
;FREE_XXX及びCHECK_IS_FREEの配列は要素の位置が同じなら同じキャラのデータをとるのを利用
IF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:20 * FREE_AI_PRIORITY:1
	IF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:30 * FREE_AI_PRIORITY:2
		LOCAL:50 = FINDELEMENT(FREE_STR, LOCAL:10)
	ELSEIF LOCAL:10 * FREE_AI_PRIORITY:0 >= LOCAL:40 * FREE_AI_PRIORITY:3
		LOCAL:50 = FINDELEMENT(FREE_STAR, LOCAL:40)
	ELSE
		LOCAL:50 = FINDELEMENT(FREE_MAG, LOCAL:30)
	ENDIF
ELSE
	IF LOCAL:20 * FREE_AI_PRIORITY:1 >= LOCAL:40 * FREE_AI_PRIORITY:3
		LOCAL:50 = FINDELEMENT(FREE_INT, LOCAL:20)
	ELSE
		LOCAL:50 = FINDELEMENT(FREE_STAR, LOCAL:40)
	ENDIF
ENDIF

UNIT_COMMANDER_BEST:0 = CHECK_IS_FREE:(LOCAL:50)

IF UNIT_COMMANDER_BEST:0 >= 0
	;１人目のキャラを候補から外す（政治パワーにフラグをつける）
	FREE_POL:(LOCAL:50) = -1

	;アップ率の合計が最も大きいキャラを次の候補にする
	LOCAL:40 = 0
	LOCAL:41 = -1
	FOR LOCAL:0, 0, LOCAL:1
		;候補に残っているキャラのみを考慮
		SIF FREE_POL:(LOCAL:0) < 0 || LOCAL:50 == LOCAL:0
			CONTINUE
		LOCAL:12 = MAX(FREE_STR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:0 / FREE_STR:(LOCAL:50)
		LOCAL:22 = MAX(FREE_INT:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:1 / FREE_INT:(LOCAL:50)
		LOCAL:32 = MAX(FREE_MAG:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:2 / FREE_MAG:(LOCAL:50)
		LOCAL:42 = MAX(FREE_STAR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 * FREE_AI_PRIORITY:3 / FREE_STAR:(LOCAL:50)
		FREE_PUP:(LOCAL:0) = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42
	NEXT
	LOCAL:51 = FINDELEMENT(FREE_PUP,  MAX(MAXARRAY(FREE_PUP), 0))
	;２人目のキャラを記録し候補から外す
	UNIT_COMMANDER_BEST:1 = LOCAL:51 >= 0 ? CHECK_IS_FREE:(LOCAL:51) # -1
	IF UNIT_COMMANDER_BEST:1 >= 0
		FREE_POL:(LOCAL:51) = -1

		LOCAL:13 = FREE_STR:(LOCAL:50) + FREE_STR:(LOCAL:51)
		LOCAL:23 = FREE_INT:(LOCAL:50) + FREE_INT:(LOCAL:51)
		LOCAL:33 = FREE_MAG:(LOCAL:50) + FREE_MAG:(LOCAL:51)
		LOCAL:43 = FREE_STAR:(LOCAL:50) + FREE_STAR:(LOCAL:51)

	ENDIF

	VARSET FREE_PUP, -1

	;アップ率の合計が最も大きいキャラを次の候補にする(３人目は歌唱・料理も考慮、外来人とホフゴブ、野盗を優先)
	LOCAL:8 = 0
	IF LOCAL:50 < 0 || !IS_SP_COUNTRY_CHARA(CHECK_IS_FREE:(LOCAL:50))
		IF LOCAL:51 < 0 || !IS_SP_COUNTRY_CHARA(CHECK_IS_FREE:(LOCAL:51))
			LOCAL:8 = 1
		ENDIF
	ENDIF
	FOR LOCAL:0, 0, LOCAL:1
		;候補に残っているキャラのみを考慮
		SIF FREE_POL:(LOCAL:0) < 0 || GROUPMATCH(LOCAL:0, LOCAL:50, LOCAL:51)
			CONTINUE
		LOCAL:2 = CHECK_IS_FREE:(LOCAL:0)
		LOCAL:12 = MAX(FREE_STR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:13 * FREE_AI_PRIORITY:0
		LOCAL:22 = MAX(FREE_INT:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:23 * FREE_AI_PRIORITY:1
		LOCAL:32 = MAX(FREE_MAG:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:33 * FREE_AI_PRIORITY:2
		LOCAL:42 = MAX(FREE_STAR:(LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:43 * FREE_AI_PRIORITY:3
		LOCAL:52 = (MAX(ABL_POWER_X(ABL:(LOCAL:2):歌唱, LOCAL:2) - ABL_50_POWER, 0) + 24000) / 24 - 1000
		LOCAL:62 = (MAX(ABL_POWER_X(ABL:(LOCAL:2):料理, LOCAL:2) - ABL_50_POWER, 0) + 24000) / 24 - 1000
		FREE_PUP:(LOCAL:0) = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42 + LOCAL:52

		IF IS_SP_COUNTRY_CHARA(CHECK_IS_FREE:(LOCAL:0)) && LOCAL:8
			FREE_PUP:(LOCAL:0) = __INT_MAX__
			BREAK
		ENDIF

	NEXT
	LOCAL:52 = FINDELEMENT(FREE_PUP, MAX(MAXARRAY(FREE_PUP), 0))

	;３人目のキャラを記録
	UNIT_COMMANDER_BEST:2 = LOCAL:52 >= 0 ? CHECK_IS_FREE:(LOCAL:52) # -1

	IF UNIT_COMMANDER_BEST:1 < 0 && UNIT_COMMANDER_BEST:2 >= 0
		UNIT_COMMANDER_BEST:1 = UNIT_COMMANDER_BEST:2
		UNIT_COMMANDER_BEST:2 = -1
	ENDIF
ELSE
;	DEBUGPRINTFORML {DAY, 3}【編成武将候補なし】:%NAME:(GET_COUNTRY_BOSS(ARG:0))%
	
ENDIF

;SIF !NOSAMES(LOCAL:50, LOCAL:51, LOCAL:52)
;	DEBUGPRINTFORML {DAY, 3}【武将重複？】:%NAME:(GET_COUNTRY_BOSS(ARG:0))%@ {LOCAL:50}:{CHECK_IS_FREE:(LOCAL:50)}, {LOCAL:51}:{CHECK_IS_FREE:(LOCAL:51)}, {LOCAL:52}:{CHECK_IS_FREE:(LOCAL:52)}

;最後にNO順に並べ替える
FOR LOCAL:0, 0, 3
	IF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
		FOR LOCAL:1, LOCAL:0 + 1, 3
			IF UNIT_COMMANDER_BEST:(LOCAL:1) >= 0
				IF NO:(UNIT_COMMANDER_BEST:(LOCAL:0)) > NO:(UNIT_COMMANDER_BEST:(LOCAL:1))
					SWAP UNIT_COMMANDER_BEST:(LOCAL:0), UNIT_COMMANDER_BEST:(LOCAL:1)
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

;-------------------------------------------------
;部隊に配置する将の組み合わせ候補のリストを作成 ARG:0=勢力番号 ARG:1=作成する部隊の数
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CREATE_COMMANDER_LIST(ARG:0, ARG:1)
;キャラが候補として残っているかどうかを記録する変数
#DIM CHECK_IS_FREE, 1000

VARSET CHECK_IS_FREE, 0

FOR LOCAL:0, 0, 10
	FOR LOCAL:1, 0, 3
		UNIT_COMMANDER_LIST:(LOCAL:0):(LOCAL:1) = -1
	NEXT
NEXT

FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
	;自国の士官のみ考慮
	IF CFLAG:(LOCAL:0):1 == ARG:0
		;自由に行動可能なら候補フラグを立てる
		CHECK_IS_FREE:(LOCAL:0) = (TMP_IS_FREE:(LOCAL:0):0 == 0)
	ENDIF
NEXT

FOR LOCAL:1, 0, ARG:1
	LOCAL:10 = ABL_50_POWER
	LOCAL:20 = ABL_50_POWER
	LOCAL:30 = 0
	LOCAL:40 = 0
	LOCAL:11 = -1
	LOCAL:21 = -1
	LOCAL:31 = -1
	FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
		;候補に残っているキャラのみを考慮
		IF CHECK_IS_FREE:(LOCAL:0)
			LOCAL:12 = ABL_POWER_X(ABL:(LOCAL:0):武闘, LOCAL:0)
			LOCAL:22 = ABL_POWER_X(ABL:(LOCAL:0):知略, LOCAL:0)
			LOCAL:32 = ABL_POWER_X(ABL:(LOCAL:0):妖術, LOCAL:0)
			LOCAL:42 = ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:0) * 10, LOCAL:0)
			;武闘パワーが最大のキャラとその値を取得
			IF LOCAL:12 > LOCAL:10
				LOCAL:10 = LOCAL:12
				LOCAL:11 = LOCAL:0
			ENDIF
			;知略パワーが最大のキャラとその値を取得
			IF LOCAL:22 > LOCAL:20
				LOCAL:20 = LOCAL:22
				LOCAL:21 = LOCAL:0
			ENDIF
			;妖術パワーが最大のキャラとその値を取得
			IF LOCAL:32 > LOCAL:30
				LOCAL:30 = LOCAL:32
				LOCAL:31 = LOCAL:0
			ENDIF
			IF LOCAL:42 > LOCAL:40
				LOCAL:40 = LOCAL:42
				LOCAL:41 = LOCAL:0
			ENDIF
		ENDIF
	NEXT

	;武闘最大値と知略最大値を比較し大きい方を持つキャラを１人目にする
	IF LOCAL:10 >= LOCAL:20
		IF LOCAL:10 >= LOCAL:30
			UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:11
		ELSE
			UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:31
		ENDIF
	ELSE
		UNIT_COMMANDER_LIST:(LOCAL:1):0 = LOCAL:21
	ENDIF

	IF UNIT_COMMANDER_LIST:(LOCAL:1):0 >= 0
		;選んだキャラを候補から外す
		CHECK_IS_FREE:(UNIT_COMMANDER_LIST:(LOCAL:1):0) = 0
	ENDIF
NEXT

FOR LOCAL:2, 1, 3
	FOR LOCAL:1, 0, ARG:1
		;アップ率の合計が最も大きいキャラを２・３人目の候補にする(歌唱・料理も考慮)
		LOCAL:80 = 0
		LOCAL:81 = -1
		LOCAL:5 = UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2 - 1)
		LOCAL:6 = UNIT_COMMANDER_LIST:(LOCAL:1):0
		LOCAL:7 = UNIT_COMMANDER_LIST:(LOCAL:1):1
		LOCAL:8 = 0
		IF (LOCAL:6 < 0 || !IS_SP_COUNTRY_CHARA(LOCAL:6)) && (LOCAL:7 < 0 || !IS_SP_COUNTRY_CHARA(LOCAL:7))
			LOCAL:8 = 1
		ENDIF

		IF LOCAL:5 >= 0
			LOCAL:13 = ABL_POWER_X(ABL:(LOCAL:5):武闘, LOCAL:5)
			LOCAL:23 = ABL_POWER_X(ABL:(LOCAL:5):知略, LOCAL:5)
			LOCAL:33 = ABL_POWER_X(ABL:(LOCAL:5):妖術, LOCAL:5)
			LOCAL:43 = ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:5), LOCAL:5)
			FOR LOCAL:0, 0, MIN(CHARANUM, 1000)
				;候補に残っているキャラのみを考慮
				IF CHECK_IS_FREE:(LOCAL:0)
					LOCAL:12 = MAX(ABL_POWER_X(ABL:(LOCAL:0):武闘, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:13
					LOCAL:22 = MAX(ABL_POWER_X(ABL:(LOCAL:0):知略, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:23
					LOCAL:32 = MAX(ABL_POWER_X(ABL:(LOCAL:0):妖術, LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:33
					LOCAL:42 = MAX(ABL_POWER_X(TMP_CHARA_STARS:(LOCAL:0), LOCAL:0) - ABL_50_POWER, 0) * 1000 / LOCAL:43
					LOCAL:52 = (MAX(ABL_POWER_X(ABL:(LOCAL:0):歌唱, LOCAL:0) - ABL_50_POWER, 0) + 24000) / 24 - 1000
					LOCAL:62 = (MAX(ABL_POWER_X(ABL:(LOCAL:0):料理, LOCAL:0) - ABL_50_POWER, 0) + 24000) / 24 - 1000
					LOCAL:82 = LOCAL:12 + LOCAL:22 + LOCAL:32 + LOCAL:42 + LOCAL:52
					;部隊能力の上昇率が最大のキャラとその値を取得
					IF LOCAL:82 > LOCAL:80
						LOCAL:80 = LOCAL:82
						LOCAL:81 = LOCAL:0
					ENDIF
					IF IS_SP_COUNTRY_CHARA(LOCAL:0) && LOCAL:8
						LOCAL:81 = LOCAL:0
						BREAK
					ENDIF
				ENDIF
			NEXT

			UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2) = LOCAL:81

			IF UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2) >= 0
				;選んだキャラを候補から外す
				CHECK_IS_FREE:(UNIT_COMMANDER_LIST:(LOCAL:1):(LOCAL:2)) = 0
			ENDIF
		ENDIF
	NEXT
NEXT

;最後にNO順に並べ替える
FOR LOCAL:2, 0, 10
	FOR LOCAL:0, 0, 3
		IF UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0) >= 0
			FOR LOCAL:1, LOCAL:0 + 1, 3
				IF UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1) >= 0
					IF NO:(UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0)) > NO:(UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1))
						SWAP UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:0), UNIT_COMMANDER_LIST:(LOCAL:2):(LOCAL:1)
					ENDIF
				ENDIF
			NEXT
		ENDIF
	NEXT
NEXT

;-------------------------------------------------
;都市ARG:0に最適な守将を配置。ARG:1を1にすると二人設定できる。
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@SET_CITY_COMMANDER_BEST(ARG:0, ARG:1 = 0)
#DIM LCOUNT
CALL CHECK_CITY_COMMANDER_BEST(ARG:0, ARG:1)
FOR LCOUNT:0, 0, MAX_CITY_COMMANDER
	CALL SET_CITY_COMMANDER(ARG:0, LCOUNT:0, CITY_COMMANDER_BEST:(LCOUNT:0))
NEXT
;-------------------------------------------------
;都市ARG:0に最適な守将を確認。ARG:1を1にすると二人設定できる。
;※直前に @TMP_CREATE_IS_FREE_MAP 関数を呼び出してから使用すること
;-------------------------------------------------
@CHECK_CITY_COMMANDER_BEST(ARG:0, ARG:1 = 0)
#DIM 勢力
#DIM LCOUNT,2
#DIM 最大
VARSET LOCAL, __INT_MIN__
VARSET CITY_COMMANDER_BEST, -1
;都市を所有する勢力の番号を取得
勢力 = CITY_OWNER:(ARG:0)

;勢力に所属してFREEな各キャラの能力を記録
FOR LCOUNT, 0, CHARANUM
	IF CFLAG:(LCOUNT):所属 == 勢力 && TMP_IS_FREE:(LCOUNT):0 == 0
		;MASTER麾下の武将は、除外フラグをたてていたら除外する
		SIF 勢力 == CFLAG:MASTER:所属 && CFLAG:(LCOUNT):最強編成除外フラグ
			CONTINUE
		;知略の重みは武闘・妖術の1/8
{
		LOCAL:(LCOUNT) = MAX(ABL_POWER_X(ABL:(LCOUNT):武闘, LCOUNT) - ABL_50_POWER, 0) + MAX(ABL_POWER_X(MIN(ABL:(LCOUNT):知略, 110), LCOUNT) - ABL_50_POWER, 0) / 8 + MAX(ABL_POWER_X(ABL:(LCOUNT):妖術, LCOUNT) - ABL_50_POWER, 0) + 
						 MAX(ABL_POWER_X(ABL:(LCOUNT):料理, LCOUNT) - ABL_50_POWER, 0) / 8 + MAX(ABL_POWER_X(ABL:(LCOUNT):歌唱, LCOUNT) - ABL_50_POWER, 0) / 8 + 
						 MAX(ABL_POWER_X(TMP_CHARA_STARS:(LCOUNT) * 10, LCOUNT) - ABL_50_POWER, 0)
}
	ENDIF
NEXT

;二人設定フラグが真なら2度回す
FOR LCOUNT:0, 0, 1 + (ARG:1 == 1)
	;LOCAL（記録した各キャラの能力）から、最大のものを探索
	最大 = MAXARRAY(LOCAL, 0)
	;最大のものが__INT_MIN__でなければ（その都市を所属している勢力に、IS_FREEなキャラが残っていれば）、そいつを登録
	IF 最大 != __INT_MIN__
		FOR LCOUNT:1, 0, CHARANUM
			IF LOCAL:(LCOUNT:1) == 最大
				CITY_COMMANDER_BEST:(LCOUNT:0) = LCOUNT:1
				LOCAL:(LCOUNT:1) = __INT_MIN__
				BREAK
			ENDIF
		NEXT
	ENDIF
NEXT