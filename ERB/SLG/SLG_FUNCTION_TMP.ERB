;SLG関数の中でも、特に高速化用の特殊変数
;状況次第で意図した結果が得られないことも多いため、取り扱いは控えるのが無難

;-------------------------------------------------
;現在の国家関係マップを作成する関数
;-------------------------------------------------
@TMP_CREATE_RELATION_MAP
VARSET TMP_COUNTRY_RELATION:(LOCAL:0):0, 0
VARSET COUNTRY_TREATY_NO
FOR LOCAL:0, 1, MAX_COUNTRY
	IF IS_COUNTRY(LOCAL:0)
		TMP_COUNTRY_RELATION:(LOCAL:0):(LOCAL:0) = 5
		FOR LOCAL:1, LOCAL:0 + 1, MAX_COUNTRY
			IF IS_COUNTRY(LOCAL:1)
				CALL CHECK_COUNTRY_RELATION(LOCAL:0, LOCAL:1)
				TMP_COUNTRY_RELATION:(LOCAL:0):(LOCAL:1) = RESULT:0
				TMP_COUNTRY_RELATION:(LOCAL:1):(LOCAL:0) = RESULT:0
				TMP_COUNTRY_RELATION_TERM:(LOCAL:0):(LOCAL:1) = RESULT:1
				TMP_COUNTRY_RELATION_TERM:(LOCAL:1):(LOCAL:0) = RESULT:1
				SELECTCASE RESULT:0
				CASE 1
					COUNTRY_TREATY_NO:(LOCAL:0):1 ++
					COUNTRY_TREATY_NO:(LOCAL:1):1 ++
				CASE 3, 4
					COUNTRY_TREATY_NO:(LOCAL:0):0 ++
					COUNTRY_TREATY_NO:(LOCAL:1):0 ++
				ENDSELECT
			ENDIF
		NEXT
	ENDIF
NEXT

;-------------------------------------------------
;現在の部隊マップを作成する関数
;-------------------------------------------------
@TMP_CREATE_UNIT_MAP
VARSET TMP_UNIT_ONCITY_CNT:(LOCAL:0):0, 0
VARSET TMP_UNIT_ONCITY_NUM:(LOCAL:0):0, 0

FOR LOCAL:0, 1, MAX_COUNTRY
	IF IS_COUNTRY(LOCAL:0)
		FOR LOCAL:1, 0, 10
			IF UNIT_SOLDIER:(LOCAL:0):(LOCAL:1) > 0
				LOCAL:3 = UNIT_POSITION:(LOCAL:0):(LOCAL:1)
				FOR LOCAL:2, 0, 20
					IF TMP_UNIT_ONCITY_CNT:(LOCAL:3):(LOCAL:2) == 0
						TMP_UNIT_ONCITY_CNT:(LOCAL:3):(LOCAL:2) = LOCAL:0
						TMP_UNIT_ONCITY_NUM:(LOCAL:3):(LOCAL:2) = LOCAL:1
						BREAK
					ENDIF
				NEXT
			ENDIF
		NEXT
	ENDIF
NEXT

;-------------------------------------------------
;君主のキャラ番号と略名マップを作成する関数
;ARG:0 略名を1文字にするフラグ
;-------------------------------------------------
@TMP_CREATE_COUNTRY_BOSS_MAP
VARSET TMP_COUNTRY_BOSS_NUMBER, -1
VARSET TMP_COUNTRY_BOSS_NAME_SHORT, ""
FOR LOCAL:0, 0, MAX_COUNTRY
	IF COUNTRY_BOSS:(LOCAL:0) >= 1
		TMP_COUNTRY_BOSS_NUMBER:(LOCAL:0) = ID_TO_CHARA(COUNTRY_BOSS:(LOCAL:0))
		SUBSTRING NAME:(TMP_COUNTRY_BOSS_NUMBER:(LOCAL:0)), 0, 2
		TMP_COUNTRY_BOSS_NAME_SHORT:(LOCAL:0) = %RESULTS:0%
	ENDIF
NEXT

;-------------------------------------------------
;国家同士の隣接関係マップを作成する関数
;LOCAL 0:起点となる都市 , 1:起点都市側のCITY_ROOT参照用カウンタ
;      2:起点都市に隣接する中継点のCITY_ROOT参照用カウンタ
;      5:参照先の都市番号 , 6:起点都市に隣接する中継点に隣接する都市の番号
;-------------------------------------------------
@TMP_CREATE_COUNTRY_NEIBORING_MAP
VARSET TMP_COUNTRY_IS_NEIBORING, 0
FOR LOCAL:0 , 1 , MAX_CITY
	;中継点ではなく中立都市でもない
	IF CITY_TYPE:(LOCAL:0) == 0 && CITY_OWNER:(LOCAL:0)
		FOR LOCAL:1 , 0 , 10
			;CITY_ROOTから隣接している都市を参照
			LOCAL:5 = CITY_ROOT:(LOCAL:0):(LOCAL:1)
			;中継点ではなく中立都市でもない
			IF CITY_TYPE:(LOCAL:5) == 0 && CITY_OWNER:(LOCAL:5)
			;両都市の支配勢力が異なる
				IF CITY_OWNER:(LOCAL:0) != CITY_OWNER:(LOCAL:5)
					;起点側の勢力から見て対象都市の支配勢力との隣接フラグだけを立てる
					TMP_COUNTRY_IS_NEIBORING:(CITY_OWNER:(LOCAL:0)):(CITY_OWNER:(LOCAL:5)) = 1
;					DEBUGPRINTFORML 接続 {LOCAL:0} , {LOCAL:5}
				ENDIF
			;中継点であれば更にループを展開
			ELSEIF CITY_TYPE:(LOCAL:5) == 1
				FOR LOCAL:2 , 0 , 10
					;CITY_ROOTから隣接している都市を参照
					LOCAL:6 = CITY_ROOT:(LOCAL:5):(LOCAL:2)
					;中継点ではなく中立都市でもない
					IF CITY_TYPE:(LOCAL:6) == 0 && CITY_OWNER:(LOCAL:6)
					;両都市の支配勢力が異なる
						IF CITY_OWNER:(LOCAL:0) != CITY_OWNER:(LOCAL:6)
							;起点側の勢力から見て対象都市の支配勢力との隣接フラグだけを立てる
							TMP_COUNTRY_IS_NEIBORING:(CITY_OWNER:(LOCAL:0)):(CITY_OWNER:(LOCAL:6)) = 1
;							DEBUGPRINTFORML 中継 {LOCAL:0} , {LOCAL:6}
						ENDIF
					ENDIF
				NEXT
			ENDIF
		NEXT
	ENDIF
NEXT

;幻想郷春の都市総当り方式。IS_ROOTが複数の中継点に対応しだしたらこちらのほうが安全に運用できます
;変更点は最初に勢力別で回すのではなく、別勢力でつながっている都市があれば両都市の支配勢力を見て処理をする感じです
;起点となる都市
;FOR LOCAL:0 , 1 , MAX_CITY
;	;中継点ではなく中立都市でもない
;	IF CITY_TYPE:(LOCAL:0) == 0 && CITY_OWNER:(LOCAL:0)
;		;隣接を確認する都市
;		FOR LOCAL:1 , 1 , MAX_CITY
;			;中継点ではなく中立都市でもない
;			IF CITY_TYPE:(LOCAL:0) == 0 && CITY_OWNER:(LOCAL:1)
;			;両都市の支配勢力が異なり、かつ２都市が接続している
;				IF CITY_OWNER:(LOCAL:0) != CITY_OWNER:(LOCAL:1) && IS_ROOT(LOCAL:0, LOCAL:1)
;					;起点側の勢力から見て対象都市の支配勢力との隣接フラグだけを立てる
;					TMP_COUNTRY_IS_NEIBORING:(CITY_OWNER:(LOCAL:0)):(CITY_OWNER:(LOCAL:1)) = 1
;				ENDIF
;			ENDIF
;		NEXT
;	ENDIF
;NEXT

;-------------------------------------------------
;連合による討伐対象のマップを作成する関数
;-------------------------------------------------
@TMP_CREATE_UNION_TARGET_MAP
VARSET TMP_COUNTRY_UNION_TARGET, -1
FOR LOCAL:0, 0, MAX_COUNTRY
	IF COUNTRY_BOSS:(LOCAL:0) >= 1
		TMP_COUNTRY_UNION_TARGET:(LOCAL:0) = GET_UNION_TARGET(LOCAL:0)
	ENDIF
NEXT

;-------------------------------------------------
;ARG:0番の都市上に敵勢力部隊が存在するかどうかを判定する関数
;-------------------------------------------------
@TMP_IS_STAY_ENEMY_UNIT(ARG:0)
#FUNCTION
IF ARG:0 < 0 || ARG:0 >= 100
	RETURNF 0
ENDIF

FOR LOCAL:0, 0, 20
	IF TMP_UNIT_ONCITY_CNT:(ARG:0):(LOCAL:0) > 0 && TMP_COUNTRY_RELATION:(CITY_OWNER:(ARG:0)):(TMP_UNIT_ONCITY_CNT:(ARG:0):(LOCAL:0)) == 0
		RETURNF 1
	ENDIF
NEXT
RETURNF 0

;-------------------------------------------------
;士官の部隊所属マップを作成する関数(0=フリー、1=遊撃、2=防衛、-1=その他特殊状態)
;こちらに条件を追加した場合は、@IS_FREEにも追加すること
;-------------------------------------------------
@TMP_CREATE_IS_FREE_MAP
CVARSET TMP_IS_FREE, 0, 0

FOR LOCAL:0, 0, CHARANUM
	;CFLAGのチェック
	IF CFLAG:(LOCAL:0):捕虜先 || CFLAG:(LOCAL:0):16 || CFLAG:(LOCAL:0):特殊状態フラグ
		TMP_IS_FREE:(LOCAL:0):0 = -1
		CONTINUE
	;素質チェック
	ELSEIF TALENT:(LOCAL:0):触手妊娠 || TALENT:(LOCAL:0):Ａ触手妊娠 || IS_ANIMAL(LOCAL:0)
		TMP_IS_FREE:(LOCAL:0):0 = -1
		CONTINUE
	;その他のチェック
	ELSEIF COOLTIME:(LOCAL:0):0 || (LOCAL:0 == GET_COOK()) || !CHECKDVAR(LOCAL:0)
		TMP_IS_FREE:(LOCAL:0):0 = -1
		CONTINUE
	ENDIF
NEXT

FOR LOCAL:0, 0, MAX_CITY
	FOR LOCAL:1, 0, 2
		LOCAL:2 = GET_CITY_COMMANDER(LOCAL:0, LOCAL:1)
		IF LOCAL:2 >= 0
			TMP_IS_FREE:(LOCAL:2):0 = 1
		ENDIF
	NEXT
NEXT
FOR LOCAL:0, 0, MAX_COUNTRY
	IF IS_COUNTRY(LOCAL:0)
		FOR LOCAL:1, 0, 10
			IF UNIT_SOLDIER:(LOCAL:0):(LOCAL:1) > 0
				FOR LOCAL:2, 0, 3
					LOCAL:3 = GET_UNIT_COMMANDER(LOCAL:0, LOCAL:1, LOCAL:2)
					IF LOCAL:3 >= 0
						TMP_IS_FREE:(LOCAL:3):0 = 1
					ENDIF
				NEXT
			ENDIF
		NEXT
	ENDIF
NEXT

;-------------------------------------------------
;ARG:0番の勢力について、フリーな武将の数を取得する関数
;直前に TMP_CREATE_IS_FREE_MAP 関数の呼び出しが必要
;-------------------------------------------------
@TMP_GET_IS_FREE_NUM(ARG:0)
#FUNCTION
#DIM 人数
VARSET 人数
FOR LOCAL:0, 0, CHARANUM
	IF CFLAG:(LOCAL:0):所属 == ARG:0 && TMP_IS_FREE:(LOCAL:0):0 == 0
		人数 ++
	ENDIF
NEXT
RETURNF 人数
;-------------------------------------------------
;ARG:0番の勢力について、政治パワーの合計値を返す関数
;直前に TMP_CREATE_IS_FREE_MAP 関数の呼び出しが必要
;-------------------------------------------------
@TMP_GET_POLITICS_POWER(ARG:0)
#FUNCTION
LOCAL:1 = 0
FOR LOCAL:0, 0, CHARANUM
	IF CFLAG:(LOCAL:0):1 == ARG:0 && TMP_IS_FREE:(LOCAL:0):0 == 0 && ABL:(LOCAL:0):政治 >= 50
		LOCAL:1 += ABL_POWER_X(ABL:(LOCAL:0):政治, LOCAL:0)
	ENDIF
NEXT
RETURNF LOCAL:1

;-------------------------------------------------
;ARG:0番の勢力について、料理パワーの合計値を返す関数
;直前に TMP_CREATE_IS_FREE_MAP 関数の呼び出しが必要
;-------------------------------------------------
@TMP_GET_COOKING_POWER(ARG:0)
#FUNCTION
LOCAL:1 = 0
FOR LOCAL:0, 0, CHARANUM
	IF CFLAG:(LOCAL:0):1 == ARG:0 && TMP_IS_FREE:(LOCAL:0):0 == 0 && ABL:(LOCAL:0):料理 >= 50
		LOCAL:1 += ABL_POWER_X(ABL:(LOCAL:0):料理, LOCAL:0)
	ENDIF
NEXT
RETURNF LOCAL:1

;-------------------------------------------------
;●戦線の計算についてのメモ
;-------------------------------------------------
;	新たに都市Ａを攻略した場合
;		Ａが敵都市と隣接していれば戦線＋1
;	Ａが隣接する自軍の都市について
;		敵都市と隣接していなければ戦線－1

;	都市Ａを奪われた場合
;		Ａが敵都市と隣接していれば戦線－1
;	Ａが隣接する自軍の都市について
;		敵都市と隣接していなければ戦線＋1

;	※敵都市……自軍・無所属・Ａ以外の都市

;-------------------------------------------------
;ARG:0番の勢力がARG:1番の都市を獲得した場合に増減する戦線の数を返す
;-------------------------------------------------
@TMP_CHANGE_LINE_ONGET(ARG:0, ARG:1)
#FUNCTION
LOCAL:10 = 0

;隣接都市のリストを作成
LOCAL:9 = 0
FOR LOCAL:0, 0, 10
	LOCAL:3 = CITY_ROOT:(ARG:1):(LOCAL:0)
	IF LOCAL:3 > 0
		;都市の場合
		IF CITY_TYPE:(LOCAL:3) == 0
			LOCAL:(LOCAL:9 + 20) = LOCAL:3
			LOCAL:9 ++
		;中継地点の場合
		ELSE
			;もう一段階ルート探索
			FOR LOCAL:1, 0, 10
				LOCAL:4 = CITY_ROOT:(LOCAL:3):(LOCAL:1)
				IF LOCAL:4 > 0 && LOCAL:4 != ARG:1
					LOCAL:(LOCAL:9 + 20) = LOCAL:4
					LOCAL:9 ++
				ENDIF
			NEXT
		ENDIF
	ENDIF
NEXT

;●都市ARG:1が敵都市と隣接していれば戦線＋1
FOR LOCAL:0, 0, LOCAL:9
	LOCAL:3 = CITY_OWNER:(LOCAL:(LOCAL:0 + 20))
	;無所属都市は無害なものとみなして、期限付き同盟以下の関係の勢力は敵とみなして判定
	IF LOCAL:3 != 0 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:3) <= 3
		;戦線を＋1
		LOCAL:10 ++
		BREAK
	ENDIF
NEXT

;●隣接する自軍の都市について、他の敵都市と隣接していなければ戦線－1
FOR LOCAL:0, 0, LOCAL:9
	LOCAL:3 = LOCAL:(LOCAL:0 + 20)
	LOCAL:4 = CITY_OWNER:(LOCAL:3)
	IF LOCAL:4 == ARG:0
		;隣接する自軍の都市１つにつき、戦線を－1する
		LOCAL:10 --
		FOR LOCAL:1, 0, 10
			LOCAL:5 = CITY_ROOT:(LOCAL:3):(LOCAL:1)
			IF LOCAL:5 > 0 && LOCAL:5 != ARG:1
				;都市の場合
				IF CITY_TYPE:(LOCAL:5) == 0
					LOCAL:6 = CITY_OWNER:(LOCAL:5)
					IF LOCAL:6 != 0 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:6) <= 3
						;他の敵都市と隣接していれば、事前に減らした分をキャンセルするために戦線を＋1
						LOCAL:10 ++
						BREAK
					ENDIF
				;中継地点の場合
				ELSE
					LOCAL:11 = 0
					;もう一段階ルート探索
					FOR LOCAL:2, 0, 10
						LOCAL:6 = CITY_ROOT:(LOCAL:5):(LOCAL:2)
						IF LOCAL:6 > 0 && LOCAL:6 != LOCAL:3 && LOCAL:6 != ARG:1
							LOCAL:7 = CITY_OWNER:(LOCAL:6)
							IF LOCAL:7 != 0 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:7) <= 3
								;他の敵都市と隣接していれば、事前に減らした分をキャンセルするために戦線を＋1
								LOCAL:10 ++
								LOCAL:11 = 1
								BREAK
							ENDIF
						ENDIF
					NEXT
					;二重ループから抜けるためのフラグ管理
					IF LOCAL:11
						BREAK
					ENDIF
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

RETURNF LOCAL:10

;-------------------------------------------------
;ARG:0番の勢力がARG:1番の都市を失った場合に増減する戦線の数を返す
;-------------------------------------------------
@TMP_CHANGE_LINE_ONLOSE(ARG:0, ARG:1)
#FUNCTION
LOCAL:10 = 0

;隣接都市のリストを作成
LOCAL:9 = 0
FOR LOCAL:0, 0, 10
	LOCAL:3 = CITY_ROOT:(ARG:1):(LOCAL:0)
	IF LOCAL:3 > 0
		;都市の場合
		IF CITY_TYPE:(LOCAL:3) == 0
			LOCAL:(LOCAL:9 + 20) = LOCAL:3
			LOCAL:9 ++
		;中継地点の場合
		ELSE
			;もう一段階ルート探索
			FOR LOCAL:1, 0, 10
				LOCAL:4 = CITY_ROOT:(LOCAL:3):(LOCAL:1)
				IF LOCAL:4 > 0 && LOCAL:4 != ARG:1
					LOCAL:(LOCAL:9 + 20) = LOCAL:4
					LOCAL:9 ++
				ENDIF
			NEXT
		ENDIF
	ENDIF
NEXT

;●都市ARG:1が敵都市と隣接していれば戦線－1
FOR LOCAL:0, 0, LOCAL:9
	LOCAL:3 = CITY_OWNER:(LOCAL:(LOCAL:0 + 20))
	;無所属都市は無害なものとみなして、期限付き同盟以下の関係の勢力は敵とみなして判定
	IF LOCAL:3 != 0 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:3) <= 3
		;戦線を－1
		LOCAL:10 --
		BREAK
	ENDIF
NEXT

;●隣接する自軍の都市について、他の敵都市と隣接していなければ戦線＋1
FOR LOCAL:0, 0, LOCAL:9
	LOCAL:3 = LOCAL:(LOCAL:0 + 20)
	LOCAL:4 = CITY_OWNER:(LOCAL:3)
	IF LOCAL:4 == ARG:0
		;隣接する自軍の都市１つにつき、戦線を＋1する
		LOCAL:10 ++
		FOR LOCAL:1, 0, 10
			LOCAL:5 = CITY_ROOT:(LOCAL:3):(LOCAL:1)
			IF LOCAL:5 > 0 && LOCAL:5 != ARG:1
				;都市の場合
				IF CITY_TYPE:(LOCAL:5) == 0
					LOCAL:6 = CITY_OWNER:(LOCAL:5)
					IF LOCAL:6 != 0 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:6) <= 3
						;他の敵都市と隣接していれば、事前に減らした分をキャンセルするために戦線を－1
						LOCAL:10 --
						BREAK
					ENDIF
				;中継地点の場合
				ELSE
					LOCAL:11 = 0
					;もう一段階ルート探索
					FOR LOCAL:2, 0, 10
						LOCAL:6 = CITY_ROOT:(LOCAL:5):(LOCAL:2)
						IF LOCAL:6 > 0 && LOCAL:6 != LOCAL:3 && LOCAL:6 != ARG:1
							LOCAL:7 = CITY_OWNER:(LOCAL:6)
							IF LOCAL:7 != 0 && TMP_COUNTRY_RELATION:(ARG:0):(LOCAL:7) <= 3
								;他の敵都市と隣接していれば、事前に減らした分をキャンセルするために戦線を－1
								LOCAL:10 --
								LOCAL:11 = 1
								BREAK
							ENDIF
						ENDIF
					NEXT
					;二重ループから抜けるためのフラグ管理
					IF LOCAL:11
						BREAK
					ENDIF
				ENDIF
			ENDIF
		NEXT
	ENDIF
NEXT

RETURNF LOCAL:10

;-----------------------------
;勢力の星評価を用意
;-----------------------------
@TMP_PREPARE_COUNTRY_STARS()
#DIM 士官数, MAX_COUNTRY
#DIM 都市数, MAX_COUNTRY
#DIM 能力値, MAX_COUNTRY
#DIM 経済値, MAX_COUNTRY
#DIM 防衛値, MAX_COUNTRY
#DIM 合計ポイント, MAX_COUNTRY
#DIM 勢力数
VARSET 士官数, __INT_MIN__
VARSET 都市数, __INT_MIN__
VARSET 能力値, __INT_MIN__
VARSET 経済値, __INT_MIN__
VARSET 防衛値, __INT_MIN__
VARSET 合計ポイント, __INT_MAX__
VARSET 勢力数, 0
VARSET TMP_COUNTRY_STARS, 0
;---ランキング用TMP_COUNTRY_STARS数準備シーケンス---
;値合計用意
FOR LOCAL, 0, MAX_COUNTRY
	IF IS_COUNTRY(LOCAL)
		士官数:LOCAL = GET_COMMANDER_NUM(LOCAL)
		都市数:LOCAL = GET_OWN_CITY(LOCAL)
		経済値:LOCAL = GET_SUM_ECONOMY(LOCAL)
		防衛値:LOCAL = GET_SUM_GUARD(LOCAL)
		勢力数 ++
		能力値:LOCAL = 0
		合計ポイント:LOCAL = 0
		FOR LOCAL:1, 0, CHARANUM
			SIF LOCAL == CFLAG:(LOCAL:1):所属
				能力値:LOCAL += (ABL:(LOCAL:1):武闘 >= 60) + (ABL:(LOCAL:1):知略 >= 60) + (ABL:(LOCAL:1):政治 >= 60) + (ABL:(LOCAL:1):妖術 >= 0) + (ABL:(LOCAL:1):料理 >= 50) + (ABL:(LOCAL:1):歌唱 >= 50)
		NEXT
	ENDIF
NEXT

;ポイント用意　各分野の順位の値の合計なので、小さい方がよい
;倍率が1より小さければ大勢に影響を与えない分野、大きければ与える分野
FOR LOCAL, 0, 勢力数
	LOCAL:1 = FINDELEMENT(士官数, MAXARRAY(士官数))
	士官数:(LOCAL:1) = __INT_MIN__
	合計ポイント:(LOCAL:1) += LOCAL * 2 / 3

	LOCAL:1 = FINDELEMENT(都市数, MAXARRAY(都市数))
	都市数:(LOCAL:1) = __INT_MIN__
	合計ポイント:(LOCAL:1) += LOCAL

	LOCAL:1 = FINDELEMENT(能力値, MAXARRAY(能力値))
	能力値:(LOCAL:1) = __INT_MIN__
	合計ポイント:(LOCAL:1) += LOCAL * 2

	LOCAL:1 = FINDELEMENT(経済値, MAXARRAY(経済値))
	経済値:(LOCAL:1) = __INT_MIN__
	合計ポイント:(LOCAL:1) += LOCAL * 3 / 2

	LOCAL:1 = FINDELEMENT(防衛値, MAXARRAY(防衛値))
	防衛値:(LOCAL:1) = __INT_MIN__
	合計ポイント:(LOCAL:1) += LOCAL / 2
NEXT

;TMP_COUNTRY_STARSの数
LOCAL:2 = 1
;このTMP_COUNTRY_STARS数でのTMP_COUNTRY_STARS付与回数
LOCAL:3 = 0

;TMP_COUNTRY_STARSを付与
FOR LOCAL, 0, 勢力数
	LOCAL:1 = FINDELEMENT(合計ポイント, MINARRAY(合計ポイント))
	合計ポイント:(LOCAL:1) = __INT_MAX__
	TMP_COUNTRY_STARS:(LOCAL:1) = LOCAL:2
	LOCAL:3 ++
	IF LOCAL:2 <= 勢力数 % 5
		IF 勢力数 / 5 + 1 <= LOCAL:3
			LOCAL:3 = 0
			LOCAL:2 ++
		ENDIF
	ELSEIF 勢力数 / 5 <= LOCAL:3
		LOCAL:3 = 0
		LOCAL:2 ++
	ENDIF
	;そのTMP_COUNTRY_STARS数でTMP_COUNTRY_STARSを与えた回数が勢力数の1/5より大きい、ないしそのTMP_COUNTRY_STARS数が総数の5で割ったあまりなら継続
NEXT

;-----------------------------
;;勢力の難易度を表示
;TMP_CREATE_STARS_MAPとセット
;-----------------------------
@TMP_PRINT_COUNTRY_DIFFICULTY(勢力番号)
#DIM 勢力番号
SELECTCASE TMP_COUNTRY_STARS:勢力番号
	CASE 1
		LOCAL:1 = COLOR("水色")
	CASE 2
		LOCAL:1 = COLOR("黄緑")
	CASE 3
		LOCAL:1 = COLOR("緑")
	CASE 4
		LOCAL:1 = COLOR("注意")
	CASE 5
		LOCAL:1 = COLOR("警告")
ENDSELECT
FOR LOCAL, 0, 5
	IF LOCAL < TMP_COUNTRY_STARS:勢力番号
		CALL COLORPRINTFORM("★", LOCAL:1)
	ELSE
		PRINT ☆
	ENDIF
NEXT

;-----------------------------
;星評価を表示
;TMP_CREATE_STARS_MAPとセット
;-----------------------------
@TMP_PRINT_COUNTRY_STARS(勢力番号)
#DIM 勢力番号
SELECTCASE TMP_COUNTRY_STARS:勢力番号
	CASE 1
		LOCAL:1 = COLOR("桃")
	CASE 2
		LOCAL:1 = COLOR("橙")
	CASE 3
		LOCAL:1 = COLOR("緑")
	CASE 4
		LOCAL:1 = COLOR("水色")
	CASE 5
		LOCAL:1 = COLOR("灰色")
ENDSELECT
LOCAL:2 = 6 - TMP_COUNTRY_STARS:勢力番号
FOR LOCAL, 0, 5
	IF LOCAL < LOCAL:2
		CALL COLORPRINTFORM("★", LOCAL:1)
	ELSE
		PRINT ☆
	ENDIF
NEXT

;-----------------------------
;キャラの星評価を用意
;-----------------------------
@TMP_PREPARE_CHARA_STARS()
#DIM 合計ポイント, 1000
#DIM キャラ数
#DIM 能力 = GETNUM(ABL, "武闘"), GETNUM(ABL, "知略"), GETNUM(ABL, "政治"), GETNUM(ABL, "妖術"), GETNUM(ABL, "料理"), GETNUM(ABL, "歌唱")
VARSET 合計ポイント, __INT_MAX__

;値合計用意
FOR LOCAL, 0, CHARANUM
	合計ポイント:LOCAL = 0
	合計ポイント:LOCAL += ABL:LOCAL:武闘
	合計ポイント:LOCAL += ABL:LOCAL:知略
	合計ポイント:LOCAL += ABL:LOCAL:政治
	合計ポイント:LOCAL += ABL:LOCAL:妖術 * 3 / 2
	合計ポイント:LOCAL += MAX(ABL:LOCAL:料理 - 50, 0)
	合計ポイント:LOCAL += MAX(ABL:LOCAL:歌唱 - 50, 0)
	FOR LOCAL:1, 0, VARSIZE("能力")
		SELECTCASE 能力:(LOCAL:1)
			CASE GETNUM(ABL, "武闘"), GETNUM(ABL, "知略"), GETNUM(ABL, "政治")
				SELECTCASE ALPHABET_RANK(ABL:LOCAL:(能力:(LOCAL:1)), 0)
					CASE "S"
						合計ポイント:LOCAL += 15
					CASE "A"
						合計ポイント:LOCAL += 10
					CASE "B"
						合計ポイント:LOCAL += 5
				ENDSELECT
			CASE GETNUM(ABL, "妖術")
				SELECTCASE ALPHABET_RANK(ABL:LOCAL:(能力:(LOCAL:1)), 1)
					CASE "S"
						合計ポイント:LOCAL += 30
					CASE "A"
						合計ポイント:LOCAL += 25
					CASE "B"
						合計ポイント:LOCAL += 20
					CASE "C"
						合計ポイント:LOCAL += 15
					CASE "D"
						合計ポイント:LOCAL += 10
					CASE "E"
						合計ポイント:LOCAL += 5
				ENDSELECT
			CASE GETNUM(ABL, "料理"), GETNUM(ABL, "歌唱")
				SELECTCASE ALPHABET_RANK(ABL:LOCAL:(能力:(LOCAL:1)), 2)
					CASE "S"
						合計ポイント:LOCAL += 20
					CASE "A"
						合計ポイント:LOCAL += 15
					CASE "B"
						合計ポイント:LOCAL += 10
					CASE "C"
						合計ポイント:LOCAL += 5
				ENDSELECT
		ENDSELECT
	NEXT
	FOR LOCAL:1, 0, VARSIZE("SLG_TALENT_NAME")
		SIF GETBIT(TALENT:LOCAL:ＳＬＧ素質, LOCAL:1)
			合計ポイント:LOCAL += SLG_TALENT_PRICE / 5000
	NEXT
NEXT

;TMP_CHARA_STARSの数
LOCAL:2 = 1
;このTMP_CHARA_STARS数でのTMP_CHARA_STARS付与回数
LOCAL:3 = 0

;TMP_CHARA_STARSを小さい順に付与
FOR LOCAL, 0, CHARANUM
	LOCAL:1 = FINDELEMENT(合計ポイント, MINARRAY(合計ポイント))
	合計ポイント:(LOCAL:1) = __INT_MAX__
	TMP_CHARA_STARS:(LOCAL:1) = LOCAL:2
	LOCAL:3 ++
	IF LOCAL:2 <= CHARANUM % 10
		IF CHARANUM / 10 + 1 <= LOCAL:3
			LOCAL:3 = 0
			LOCAL:2 ++
		ENDIF
	ELSEIF CHARANUM / 10 <= LOCAL:3
		LOCAL:3 = 0
		LOCAL:2 ++
	ENDIF
	;そのTMP_CHARA_STARS数でTMP_CHARA_STARSを与えた回数が勢力数の1/10より大きい、ないしそのTMP_CHARA_STARS数が総数の10で割ったあまりなら継続
NEXT

;-----------------------------
;キャラの星評価を表示
;TMP_CREATE_STARS_MAPとセット
;-----------------------------
@TMP_PRINT_CHARA_STARS(対象)
#DIM 対象
FOR LOCAL, 0, 10
	IF LOCAL < TMP_CHARA_STARS:対象
		CALL COLORPRINTFORM("★", GET_CHARA_STARS_COLOR(対象))
	ELSE
		PRINT ☆
	ENDIF
NEXT
;-----------------------------
;キャラの星評価をシンプルに表示
;-----------------------------
@TMP_PRINT_CHARA_STARS_NUM(対象)
#DIM 対象
CALL COLORPRINTFORM(@"★{TMP_CHARA_STARS:対象, 2, RIGHT}", GET_CHARA_STARS_COLOR(対象))

;-----------------------------
;キャラの星評価用の色を取得
;-----------------------------
@GET_CHARA_STARS_COLOR(対象)
#FUNCTION
#DIM 対象
SELECTCASE TMP_CHARA_STARS:対象
	CASE 1
		RETURNF COLOR("灰色")
	CASE 2
		RETURNF COLOR("明灰色")
	CASE 3
		RETURNF COLOR("青")
	CASE 4
		RETURNF COLOR("水色")
	CASE 5
		RETURNF COLOR("緑")
	CASE 6
		RETURNF COLOR("黄")
	CASE 7
		RETURNF COLOR("橙")
	CASE 8
		RETURNF COLOR("赤")
	CASE 9
		RETURNF COLOR("桃")
	CASE 10
		RETURNF COLOR("パ紫")
ENDSELECT
RETURNF 0x000000

;-----------------------------
;ある都市が各勢力の都市と接続しているかのマップを作成
;-----------------------------
@TMP_CREATE_CONNECTION_MAP
VARSET TMP_CONNECTED_TO_US, 0
VARSET TMP_CONNECTED_TO_US_ONLY, 0

FOR LOCAL, 0, MAX_COUNTRY
	FOR LOCAL:1, 0, MAX_CITY
		IF CITY_OWNER:(LOCAL:1) == LOCAL
			TMP_CONNECTED_TO_US:(LOCAL):(LOCAL:1) = 1
			CONTINUE
		ENDIF
		FOR LOCAL:2, 0, 10
			SIF CITY_ROOT:(LOCAL:1):(LOCAL:2) < 1
				BREAK
			IF CITY_TYPE:(CITY_ROOT:(LOCAL:1):(LOCAL:2)) == 1
				FOR LOCAL:3, 0, 10
					SIF CITY_ROOT:(CITY_ROOT:(LOCAL:1):(LOCAL:2)):(LOCAL:3) < 1
						BREAK
					SIF CITY_ROOT:(CITY_ROOT:(LOCAL:1):(LOCAL:2)):(LOCAL:3) == CITY_ROOT:(LOCAL:1):(LOCAL:2)
						CONTINUE
					IF CITY_OWNER:(CITY_ROOT:(CITY_ROOT:(LOCAL:1):(LOCAL:2)):(LOCAL:3)) == LOCAL
						TMP_CONNECTED_TO_US:(LOCAL):(LOCAL:1) = 1
						BREAK
					ENDIF
				NEXT
			ENDIF
			SIF CITY_OWNER:(CITY_ROOT:(LOCAL:1):(LOCAL:2)) == LOCAL
				TMP_CONNECTED_TO_US:(LOCAL):(LOCAL:1) = 1
			SIF TMP_CONNECTED_TO_US:(LOCAL):(LOCAL:1)
				BREAK
		NEXT
	NEXT

	FOR LOCAL:1, 0, MAX_CITY
		;そもそも自勢力都市と繋がっていない場合、および都市所有者が自分でない場合は駄目
		SIF !TMP_CONNECTED_TO_US:(LOCAL):(LOCAL:1)
			CONTINUE
		SIF CITY_OWNER:(LOCAL:1) != LOCAL
			CONTINUE
		FOR LOCAL:2, 0, 10
			LOCAL:4 = 0
			SIF CITY_ROOT:(LOCAL:1):(LOCAL:2) < 1
				BREAK
			IF CITY_TYPE:(CITY_ROOT:(LOCAL:1):(LOCAL:2)) == 1
				FOR LOCAL:3, 0, 10
					SIF CITY_ROOT:(CITY_ROOT:(LOCAL:1):(LOCAL:2)):(LOCAL:3) < 1
						CONTINUE
					SIF CITY_ROOT:(CITY_ROOT:(LOCAL:1):(LOCAL:2)):(LOCAL:3) == CITY_ROOT:(LOCAL:1):(LOCAL:2)
						CONTINUE
					IF CITY_OWNER:(CITY_ROOT:(CITY_ROOT:(LOCAL:1):(LOCAL:2)):(LOCAL:3)) != LOCAL
						LOCAL:4 = 1
						BREAK
					ENDIF
				NEXT
			ENDIF
			SIF CITY_TYPE:(CITY_ROOT:(LOCAL:1):(LOCAL:2)) != 1 && CITY_OWNER:(CITY_ROOT:(LOCAL:1):(LOCAL:2)) != LOCAL
				LOCAL:4 = 1
			SIF LOCAL:4
				BREAK
		NEXT
		SIF !LOCAL:4
			TMP_CONNECTED_TO_US_ONLY:(LOCAL):(LOCAL:1) = 1
	NEXT
NEXT

;-----------------------------
;各勢力がどう飛び地になっているかのマップを作成
;-----------------------------
@TMP_CREATE_ENCLAVE_MAP
#DIM CURRENT_NODE
#DIM CURRENT_LOOP
#DIM WORK_NODE
#DIM NODE_STACK, MAX_CITY
#DIM LOOP_STACK, MAX_CITY
#DIM CHECKED, MAX_CITY
#DIM PASSED, MAX_CITY
#DIM ENCLAVE_SIZE
#DIM POINTER
VARSET TMP_ENCLAVE_NUM
VARSET TMP_ENCLAVE_SIZE
VARSET TMP_MAX_ENCLAVE_SIZE

FOR LOCAL, 0, MAX_COUNTRY
	VARSET NODE_STACK
	VARSET LOOP_STACK
	VARSET CHECKED
	VARSET POINTER
	VARSET PASSED
	CURRENT_NODE = 1
	CURRENT_LOOP = 0
	FOR LOCAL:1, 1, GET_CITY_NUM() + 1
		CURRENT_NODE = LOCAL:1
		;対象勢力の都市でなければスルー
		SIF CITY_OWNER:CURRENT_NODE != LOCAL:0
			CONTINUE
		;チェック済みなら飛ばす
		SIF CHECKED:CURRENT_NODE
			CONTINUE
		;新しい飛び地なので飛び地の数を増やす
		TMP_ENCLAVE_NUM:LOCAL ++
		ENCLAVE_SIZE ++
		;通過都市に記録
		PASSED:(ENCLAVE_SIZE - 1) = CURRENT_NODE
		;------ここから再帰処理（的なもの）-----
		$RECURSION
		;カレントノードをチェックする
		CHECKED:CURRENT_NODE = 1
		;カレントノードの接続都市を調べる
		FOR LOCAL:2, CURRENT_LOOP, 10
			WORK_NODE = CITY_ROOT:CURRENT_NODE:(LOCAL:2)
			;チェック済みなら飛ばす
			SIF CHECKED:WORK_NODE
				CONTINUE
			SIF WORK_NODE == 0
				BREAK
				
			;接続先が中継地点の場合
			;その先を見る
			IF CITY_TYPE:WORK_NODE == 1
				;中継地点はCURRENT_NODEにならないので、RECURSION冒頭のチェック処理にかからない
				;中継地点にチェックをいれておく
				CHECKED:WORK_NODE = 1

				;CURRENT_NODEでないほうの接続先を取得
				LOCAL:3 = (CITY_ROOT:WORK_NODE:0 == CURRENT_NODE ? CITY_ROOT:WORK_NODE:1 # CITY_ROOT:WORK_NODE:0)

				;接続先が対象勢力の都市でないなら飛ばす
				SIF CITY_OWNER:(LOCAL:3) != LOCAL
					CONTINUE
				;接続先がチェック済みなら飛ばす
				SIF CHECKED:(LOCAL:3)
					CONTINUE
					
				;-------------再帰処理---------------
				;飛び地サイズを増やす
				ENCLAVE_SIZE ++
				;通過都市に記録
				PASSED:(ENCLAVE_SIZE - 1) = LOCAL:3
				;スタックには中継点からの接続元であるCURRENT_NODEを入れる
				NODE_STACK:POINTER = CURRENT_NODE
				LOOP_STACK:POINTER = CURRENT_LOOP
				POINTER ++
				;CURRENT_NODEには中継先を入れる
				;スタックで中継元を入れたことで、中継点がなかったかのように振る舞う
				CURRENT_NODE = LOCAL:3
				CURRENT_LOOP = 0
				GOTO RECURSION

			;接続先が都市の場合
			ELSE
				;接続先が対象勢力の都市でないなら飛ばす
				SIF CITY_OWNER:WORK_NODE != LOCAL
					CONTINUE
				;-------------再帰処理---------------
				;飛び地サイズを増やす
				ENCLAVE_SIZE ++
				;通過都市に記録
				PASSED:(ENCLAVE_SIZE - 1) = WORK_NODE
				;スタックにCURRENT_NODEと現在のループ状況を退避
				NODE_STACK:POINTER = CURRENT_NODE
				LOOP_STACK:POINTER = CURRENT_LOOP
				POINTER ++
				;CURRENT_NODEに接続先を入れる
				CURRENT_NODE = WORK_NODE
				CURRENT_LOOP = 0
				GOTO RECURSION
			ENDIF
		NEXT
		;GOTO RECURSION(再帰呼び出しに相当)せず最後までいけたら、
		;再帰でいうRETURNの処理に入る
		POINTER --
		;ポインターが0以上（まだ再帰できる）なら再帰
		IF POINTER >= 0
			CURRENT_NODE = NODE_STACK:POINTER
			CURRENT_LOOP = LOOP_STACK:POINTER
			GOTO RECURSION
		ENDIF
		FOR LOCAL:2, 0, ENCLAVE_SIZE
			TMP_ENCLAVE_SIZE:LOCAL:(PASSED:(LOCAL:2)) = ENCLAVE_SIZE
		NEXT
		;次の都市を見る前に、初期化が必要な変数を初期化
		POINTER = 0
		ENCLAVE_SIZE = 0
	NEXT
	LOCAL:2 = 0
	FOR LOCAL:1, 0, GET_CITY_NUM() + 1
		SIF TMP_ENCLAVE_SIZE:(LOCAL):(LOCAL:1) > LOCAL:2
			LOCAL:2 = TMP_ENCLAVE_SIZE:(LOCAL):(LOCAL:1)
	NEXT
	TMP_MAX_ENCLAVE_SIZE:LOCAL = LOCAL:2
NEXT