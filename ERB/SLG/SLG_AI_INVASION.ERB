;-----------------------------------
;攻撃候補決定アルゴリズム
;-----------------------------------
@SLG_AI_INVASION_SETTARGET(ARG:0)
VARSET AI_TARGET_CITY
VARSET AI_DEPARTURE_POINT
VARSET AI_LINE_ONGET
VARSET AI_TARGET_PROPOSED
;DEBUGPRINTFORML IS_PROTECTED:{IS_PROTECTED}

IF DAY < SLG_PP:1 || IS_PROTECTED
	;DEBUGPRINTL SLG_AI_INVASION_SETTARGET離脱
	RETURN 0
ENDIF

CALL SLG_AI_CAN_CREATE_UNIT(ARG:0)
IF !RESULT
	;DEBUGPRINTL 条件満たさず。SLG_AI_INVASION_SETTARGET離脱
	RETURN 0
ENDIF

CALL SLG_AI_CREATE_INVASION_TARGET_LIST(ARG:0)

IF AI_TARGET_CITY:0 == 0
	;DEBUGPRINTL 対象なし。SLG_AI_INVASION_SETTARGET離脱
	RETURN 0
ENDIF
;DEBUGPRINTFORML SLG_AI_CREATE_PROPOSAL開始
CALL SLG_AI_CREATE_PROPOSAL(ARG:0)
CALLFORM SLG_AI_DECIDE_TARGET(ARG:0)
;空いている部隊の番号のうち最も若い番号を取得
FOR LOCAL:0, 0, MAX_UNIT
	IF UNIT_SOLDIER:(ARG:0):(LOCAL:0) <= 0
		GOTO DECIDED
	ENDIF
NEXT
$DECIDED
IF LOCAL:0 == MAX_UNIT
	RETURN 0
ENDIF
;DEBUGPRINTFORML 最終的なAI_TARGET_CITY:{AI_TARGET_CITY:RESULT}
;DEBUGPRINTFORML 最終的なAI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:RESULT}
UNIT_TARGET:(ARG:0):LOCAL = AI_TARGET_CITY:RESULT
UNIT_POSITION:(ARG:0):LOCAL = AI_DEPARTURE_POINT:RESULT
RETURN 1


;-----------------------------------
;攻撃できるかの判定
;-----------------------------------
@SLG_AI_CAN_CREATE_UNIT(ARG:0)
;自国の経済／兵数／徴兵限界／温存兵率／支配都市数
#DIM ECONOMY
#DIM MILITARY
#DIM MILITARY_LIMIT
#DIM MILITARY_PERCENTAGE
#DIM OWN_CITY
#DIM SELECTOR, 10
VARSET LOCAL

ECONOMY = GET_SUM_ECONOMY(ARG:0)
;軍事変数の取得、ただしMILITARY_PERCENTAGEは侵攻も防衛もしていない兵数で計算
MILITARY = GET_SUM_SOLDIER(ARG:0)
MILITARY_LIMIT = ECONOMY / 10
MILITARY_PERCENTAGE = COUNTRY_SOLDIER:(ARG:0) * 100 / MILITARY_LIMIT

OWN_CITY = MATCH(CITY_OWNER, ARG:0)

;士官が行動可能な状態にあるかどうかのリストを作成
CALL TMP_CREATE_IS_FREE_MAP
;行動可能な士官の数をカウント
WHILE 1
	LOCAL:0 = FINDCHARA(CFLAG:1, ARG:0, LOCAL:0)
	SIF LOCAL:0 < 0
		BREAK
	SIF TMP_IS_FREE:(LOCAL:0):0 == 0
		LOCAL:1 ++
	SIF LOCAL:0 == CHARANUM - 1
		BREAK
	LOCAL:0 ++
WEND
;DEBUGPRINTFORML {DAY,3} - 【行動可能士官数】{ARG:0, 2}:%NAME:(GET_COUNTRY_BOSS(ARG:0))% :{LOCAL:1}

SELECTOR:0 = COUNTRY_AI_TYPE:(ARG:0)

SIF LOCAL:1 <= 0 && NOSAMES(SELECTOR:0, AI_ホフゴブリン)
	RETURN 0

;●侵攻条件の判断処理
;1.部隊数が上限を超えていれば編成しない（外来／ホフゴブリンは難易度により最大編成数が増加）
SIF GET_UNIT_NUM(ARG:0) >= MIN(AI_ARMY_PROPERTY:(SELECTOR:0):7 + CONFIG:300, 10)
	RETURN 0
;2.現兵数が一定値以下であれば編成しない（緊急雇用により上限を超えることがあるため）
SIF COUNTRY_SOLDIER:(ARG:0) < AI_ARMY_PROPERTY:(SELECTOR:0):0
	RETURN 0

;3.兵数が最大兵数の既定割合以上、もしくは固定値（乱数によるゆらぎあり）のうち低い方以上あれば徴兵実行
;SELECTOR:1 兵数上限を基準にした判断値
;SELECTOR:2 最低兵数
;SELECTOR:3 固定値を元にした判断値
SELECTOR:1 = MILITARY_LIMIT * (AI_ARMY_PROPERTY:(SELECTOR:0):2 - CONFIG:300 * AI_ARMY_PROPERTY:(SELECTOR:0):3) / 100
SELECTOR:2 = AI_ARMY_PROPERTY:(SELECTOR:0):0 + CONFIG:300 * AI_ARMY_PROPERTY:(SELECTOR:0):1
SELECTOR:3 = MAX(AI_ARMY_PROPERTY:(SELECTOR:0):4 - CONFIG:300 * AI_ARMY_PROPERTY:(SELECTOR:0):5 , 0) + RAND:(AI_ARMY_PROPERTY:(SELECTOR:0):6)
;DEBUGPRINTFORML {DAY,3}【侵攻判断】{ARG:0, 2}:%NAME:(GET_COUNTRY_BOSS(ARG:0))% :{SELECTOR:0}:{SELECTOR:1}:{SELECTOR:2}
RETURN (COUNTRY_SOLDIER:(ARG:0) >= MIN(MAX(SELECTOR:1, SELECTOR:2), SELECTOR:3))


;-----------------------------------
;攻撃候補リスト作成
;-----------------------------------
@SLG_AI_CREATE_INVASION_TARGET_LIST(ARG:0)
#DIM UNION_TARGET
#DIM CNT
#DIM HAVE_TARGET
VARSET HAVE_TARGET
VARSET CNT
VARSET LOCAL
;DEBUGPRINTL SLG_AI_INVASION_TARGET_LIST開始
;連合の対象敵国を取得
UNION_TARGET = GET_UNION_TARGET(ARG:0)
;連合に参加している
IF UNION_TARGET >= 1
	;DEBUGPRINTL 連合に参加しているときの処理
	;自国・同盟国・連合国と隣接する対象敵国の都市のリストを作成
	FOR LOCAL:0, 0, MAX_CITY
		IF CITY_TYPE:(LOCAL:0) == 0 && CITY_OWNER:(LOCAL:0) == UNION_TARGET
			;既に登録されているならパス
			IF FINDELEMENT(AI_TARGET_CITY, LOCAL:0) != -1
				;DEBUGPRINTFORML CITY{LOCAL:0}を無視
				CONTINUE
			ENDIF
			LOCAL:10 = 0
			FOR LOCAL:1, 0, MAX_UNIT
				;既に自国部隊が向かっているなら1/6で対象としない
				;もしくは自国部隊が攻撃中なら1/3で対象としない
				IF (UNIT_TARGET:(ARG:0):(LOCAL:1) == LOCAL:0 && !RAND:6) || (UNIT_POSITION:(ARG:0):(LOCAL:1) == LOCAL:0 && !RAND:3)
					LOCAL:10 = 1
					BREAK
				ENDIF
			NEXT
			SIF LOCAL:10
				CONTINUE
			CALL FISHER_YATES_SHAFFLE(10)
			;CITY_ROOTを直接読んで経路チェックを行う（ループ数削減）
			FOR LOCAL:1, 0, 10
				LOCAL:3 = 1
				LOCAL:2 = CITY_ROOT:(LOCAL:0):(SHAFFLE_ARRAY:(LOCAL:1))
				;中継点が３都市以上繋がない仕様になったので簡略式で処理して中継フラグLOCAL:3を立てておく
				IF CITY_TYPE:(LOCAL:2) == 1
					LOCAL:2 = CITY_ROOT:(LOCAL:2):0 == LOCAL:0 ? CITY_ROOT:(LOCAL:2):1 # CITY_ROOT:(LOCAL:2):0
					LOCAL:3 = 0
				ENDIF
				;同盟OR連合国の都市
				IF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(LOCAL:2)) >= 2
					;対象との接続チェック
					IF LOCAL:3
					;直通ならその都市から侵攻
						AI_TARGET_CITY:CNT = LOCAL:0
						AI_DEPARTURE_POINT:CNT = LOCAL:2
						AI_LINE_ONGET:CNT = TMP_CHANGE_LINE_ONGET(ARG:0, LOCAL:0)
						;DEBUGPRINTFORML AI_TARGET_CITY:{AI_TARGET_CITY:CNT}
						;DEBUGPRINTFORML AI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:CNT}
						;DEBUGPRINTFORML AI_LINE_ONGET:{AI_LINE_ONGET:CNT}
						CNT ++
						BREAK
					;中継点経由なら中継点に敵対勢力がいなければ使用する
					ELSE
						LOCAL:10 = 0
						LOCAL:4 = CITY_ROOT:(LOCAL:0):(SHAFFLE_ARRAY:(LOCAL:1))
						;中継都市の部隊を確認（一旦凍結中）
						;CALL GET_STAY_UNIT(LOCAL:4)
						;FOR LOCAL:5, 0, 5
						;	SIF RESULT:(LOCAL:5) < 0
						;		BREAK
						;	IF TMP_COUNTRY_RELATION:(ARG:0):(RESULT:(LOCAL:5)) == 0
						;		LOCAL:10 = 1
						;		BREAK
						;	ENDIF
						;NEXT
						IF LOCAL:10 == 0
							AI_TARGET_CITY:CNT = LOCAL:0
							AI_DEPARTURE_POINT:CNT = LOCAL:2
							AI_LINE_ONGET:CNT = TMP_CHANGE_LINE_ONGET(ARG:0, LOCAL:0)
							;DEBUGPRINTFORML AI_TARGET_CITY:{AI_TARGET_CITY:CNT}
							;DEBUGPRINTFORML AI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:CNT}
							;DEBUGPRINTFORML AI_LINE_ONGET:{AI_LINE_ONGET:CNT}
							CNT ++
							BREAK
						ENDIF
					ENDIF
				ENDIF
			NEXT
		ENDIF
	NEXT
ENDIF
;連合に参加しているか、しているものの対象都市が見つからなかった
;自国/同盟国と隣接する敵対都市のリストを作成
IF UNION_TARGET < 0 || CNT == 0
	;DEBUGPRINTFORML 連合参加なし
	;先に自国の分
	FOR LOCAL:0, 0, MAX_CITY
		IF CITY_TYPE:(LOCAL:0) == 0 && TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(LOCAL:0)) == 0
			LOCAL:10 = 0
			FOR LOCAL:1, 0, MAX_UNIT
				;既に自国部隊が向かっているなら1/4で対象としない
				;もしくは自国部隊が攻撃中なら1/2で対象としない
				IF (UNIT_TARGET:(ARG:0):(LOCAL:1) == LOCAL:0 && !RAND:4) || (UNIT_POSITION:(ARG:0):(LOCAL:1) == LOCAL:0 && RAND:2)
					LOCAL:10 = 1
					BREAK
				ENDIF
			NEXT
			SIF LOCAL:10
				CONTINUE
			;既に登録されているならパス
			IF FINDELEMENT(AI_TARGET_CITY, LOCAL:0) != -1
				;DEBUGPRINTFORML CITY{LOCAL:0}を無視
				CONTINUE
			ENDIF
			CALL FISHER_YATES_SHAFFLE(10)
			;CITY_ROOTを直接読んで経路チェックを行う（ループ数削減）
			FOR LOCAL:1, 0, 10
				LOCAL:3 = 1
				LOCAL:2 = CITY_ROOT:(LOCAL:0):(SHAFFLE_ARRAY:(LOCAL:1))
				;中継点が３都市以上繋がない仕様になったので簡略式で処理して中継フラグLOCAL:3を立てておく
				IF CITY_TYPE:(LOCAL:2) == 1
					LOCAL:2 = CITY_ROOT:(LOCAL:2):0 == LOCAL:0 ? CITY_ROOT:(LOCAL:2):1 # CITY_ROOT:(LOCAL:2):0
					LOCAL:3 = 0
				ENDIF
				;同盟OR連合国の都市
				IF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(LOCAL:2)) >= 2
					;対象との接続チェック
					IF LOCAL:3
					;直通ならその都市から侵攻
						AI_TARGET_CITY:CNT = LOCAL:0
						AI_DEPARTURE_POINT:CNT = LOCAL:2
						AI_LINE_ONGET:CNT = TMP_CHANGE_LINE_ONGET(ARG:0, LOCAL:0)
						;DEBUGPRINTFORML 自国の敵国
						;DEBUGPRINTFORML AI_TARGET_CITY:{AI_TARGET_CITY:CNT}
						;DEBUGPRINTFORML AI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:CNT}
						;DEBUGPRINTFORML AI_LINE_ONGET:{AI_LINE_ONGET:CNT}
						CNT ++
						HAVE_TARGET = 1
						BREAK
					;中継点経由なら中継点に敵対勢力がいなければ使用する
					ELSE
						;LOCAL:10 = 0
						LOCAL:4 = CITY_ROOT:(LOCAL:0):(SHAFFLE_ARRAY:(LOCAL:1))
						;中継都市の部隊を確認（一旦凍結中）
						;CALL GET_STAY_UNIT(LOCAL:4)
						;FOR LOCAL:5, 0, 5
						;	SIF RESULT:(LOCAL:5) < 0
						;		BREAK
						;	IF TMP_COUNTRY_RELATION:(ARG:0):(RESULT:(LOCAL:5)) == 0
						;		LOCAL:10 = 1
						;		BREAK
						;	ENDIF
						;NEXT
						IF LOCAL:10 == 0
							AI_TARGET_CITY:CNT = LOCAL:0
							AI_DEPARTURE_POINT:CNT = LOCAL:2
							AI_LINE_ONGET:CNT = TMP_CHANGE_LINE_ONGET(ARG:0, LOCAL:0)
							;DEBUGPRINTFORML 自国の敵国
							;DEBUGPRINTFORML AI_TARGET_CITY:{AI_TARGET_CITY:CNT}
							;DEBUGPRINTFORML AI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:CNT}
							;DEBUGPRINTFORML AI_LINE_ONGET:{AI_LINE_ONGET:CNT}
							CNT ++
							HAVE_TARGET = 1
							BREAK
						ENDIF
					ENDIF
				ENDIF
			NEXT
		ENDIF
	NEXT
	;自国に隣接する敵対都市があり、かつ外交型以外なら、同盟国の隣接敵対都市にぶつかりに行くのは1/2の確率
	IF !HAVE_TARGET || RAND:2 || COUNTRY_AI_TYPE:(ARG:0) == AI_外交
		;同盟国と隣接する敵対都市のリストを作成
		FOR LOCAL:0, 0, MAX_CITY
			IF FINDELEMENT(AI_TARGET_CITY, LOCAL:0) != -1
				;DEBUGPRINTFORML CITY{LOCAL:0}を無視
				CONTINUE
			ENDIF
			LOCAL:10 = 0
			FOR LOCAL:1, 0, MAX_UNIT
				;既に自国部隊が向かっているなら1/3で対象としない
				;もしくは自国部隊が攻撃中なら対象としない
				IF (UNIT_TARGET:(ARG:0):(LOCAL:1) == LOCAL:0 && !RAND:3) || UNIT_POSITION:(ARG:0):(LOCAL:1) == LOCAL:0
					LOCAL:10 = 1
					BREAK
				ENDIF
			NEXT
			SIF LOCAL:10
				CONTINUE
			;既に登録されているならパス
			CALL FISHER_YATES_SHAFFLE(10)
			;CITY_ROOTを直接読んで経路チェックを行う（ループ数削減）
			FOR LOCAL:1, 0, 10
				LOCAL:3 = 1
				LOCAL:2 = CITY_ROOT:(LOCAL:0):(SHAFFLE_ARRAY:(LOCAL:1))
				;中継点が３都市以上繋がない仕様になったので簡略式で処理して中継フラグLOCAL:3を立てておく
				IF CITY_TYPE:(LOCAL:2) == 1
					LOCAL:2 = CITY_ROOT:(LOCAL:2):0 == LOCAL:0 ? CITY_ROOT:(LOCAL:2):1 # CITY_ROOT:(LOCAL:2):0
					LOCAL:3 = 0
				ENDIF
				;同盟OR連合国の都市
				IF TMP_COUNTRY_RELATION:(ARG:0):(CITY_OWNER:(LOCAL:2)) >= 2
					;対象との接続チェック
					IF LOCAL:3
					;直通ならその都市から侵攻
						AI_TARGET_CITY:CNT = LOCAL:0
						AI_DEPARTURE_POINT:CNT = LOCAL:2
						AI_LINE_ONGET:CNT = TMP_CHANGE_LINE_ONGET(ARG:0, LOCAL:0)
						;DEBUGPRINTFORML 同盟の敵国
						;DEBUGPRINTFORML AI_TARGET_CITY:{AI_TARGET_CITY:CNT}
						;DEBUGPRINTFORML AI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:CNT}
						;DEBUGPRINTFORML AI_LINE_ONGET:{AI_LINE_ONGET:CNT}
						CNT ++
						HAVE_TARGET = 1
						BREAK
					;中継点経由なら中継点に敵対勢力がいなければ使用する
					ELSE
						LOCAL:10 = 0
						LOCAL:4 = CITY_ROOT:(LOCAL:0):(SHAFFLE_ARRAY:(LOCAL:1))
						;中継都市の部隊を確認（一旦凍結中）
						;CALL GET_STAY_UNIT(LOCAL:4)
						;FOR LOCAL:5, 0, 5
						;	SIF RESULT:(LOCAL:5) < 0
						;		BREAK
						;	IF TMP_COUNTRY_RELATION:(ARG:0):(RESULT:(LOCAL:5)) == 0
						;		LOCAL:10 = 1
						;		BREAK
						;	ENDIF
						;NEXT
						IF LOCAL:10 == 0
							AI_TARGET_CITY:CNT = LOCAL:0
							AI_DEPARTURE_POINT:CNT = LOCAL:2
							AI_LINE_ONGET:CNT = TMP_CHANGE_LINE_ONGET(ARG:0, LOCAL:0)
							;DEBUGPRINTFORML 同盟の敵国
							;DEBUGPRINTFORML AI_TARGET_CITY:{AI_TARGET_CITY:CNT}
							;DEBUGPRINTFORML AI_DEPARTURE_POINT:{AI_DEPARTURE_POINT:CNT}
							;DEBUGPRINTFORML AI_LINE_ONGET:{AI_LINE_ONGET:CNT}
							CNT ++
							HAVE_TARGET = 1
							BREAK
						ENDIF
					ENDIF
				ENDIF
			NEXT
		NEXT
	ENDIF
ENDIF

;-----------------------------------
;攻撃候補上位選出のためのアルゴリズム生成
;-----------------------------------
@SLG_AI_CREATE_PROPOSAL(ARG:0)
SELECTCASE COUNTRY_AI_TYPE:(ARG:0)
	CASE AI_通常
		SELECTCASE RAND:100
			CASE 0 TO 29
				LOCAL = 0
				LOCALS = LINE
			CASE 30 TO 69
				LOCAL = 1
				LOCALS = ECONOMY
			CASE 70 TO 79
				LOCAL = 0
				LOCALS = GUARD
			CASE 80 TO 89
				LOCAL = 0
				LOCALS = ARMY
			CASEELSE
				LOCAL = 1
				LOCALS = RANDOM
		ENDSELECT
	CASE AI_好戦
		SELECTCASE RAND:100
			CASE 0 TO 39
				LOCAL = 1
				LOCALS = ECONOMY
			CASE 40 TO 69
				LOCAL = 0
				LOCALS = GUARD
			CASE 70 TO 89
				LOCAL = 0
				LOCALS = ARMY
			CASEELSE
				LOCAL = 0
				LOCALS = RANDOM
		ENDSELECT
	CASE AI_防衛
		SELECTCASE RAND:100
			CASE 0 TO 39
				LOCAL = 0
				LOCALS = LINE
			CASE 40 TO 69
				LOCAL = 0
				LOCALS = ARMY
			CASE 70 TO 99
				LOCAL = 0
				LOCALS = RANDOM
			CASEELSE
				LOCAL = 1
				LOCALS = RANDOM
		ENDSELECT
	CASE AI_外交
		SELECTCASE RAND:100
			CASE 0 TO 69
				LOCAL = 0
				LOCALS = LINE
			CASE 70 TO 99
				LOCAL = 1
				LOCALS = ECONOMY
			CASEELSE
				LOCAL = 1
				LOCALS = RANDOM
		ENDSELECT
	CASE AI_内政
		SELECTCASE RAND:100
			CASE 0 TO 69
				LOCAL = 1
				LOCALS = ECONOMY
			CASE 70 TO 99
				LOCAL = 0
				LOCALS = LINE
			CASEELSE
				LOCAL = 1
				LOCALS = RANDOM
		ENDSELECT
	CASE AI_蛮行
		SELECTCASE RAND:100
			CASE 0 TO 49
				LOCAL = 0
				LOCALS = ARMY
			CASE 50 TO 74
				LOCAL = 0
				LOCALS = GUARD
			CASE 75 TO 89
				LOCAL = 1
				LOCALS = ECONOMY
			CASEELSE
				LOCAL = 0
				LOCALS = RANDOM
		ENDSELECT
	CASE AI_ホフゴブリン
		SELECTCASE RAND:100
			CASE 0 TO 49
				LOCAL = 0
				LOCALS = GUARD
			CASE 50 TO 74
				LOCAL = 0
				LOCALS = ARMY
			CASE 75 TO 89
				LOCAL = 1
				LOCALS = ECONOMY
			CASEELSE
				LOCAL = 0
				LOCALS = RANDOM
		ENDSELECT
	CASEELSE
		SELECTCASE RAND:100
			CASE 0 TO 29
				LOCAL = 0
				LOCALS = LINE
			CASE 30 TO 69
				LOCAL = 1
				LOCALS = ECONOMY
			CASE 70 TO 79
				LOCAL = 0
				LOCALS = GUARD
			CASE 80 TO 89
				LOCAL = 0
				LOCALS = ARMY
			CASEELSE
				LOCAL = 1
				LOCALS = RANDOM
		ENDSELECT
ENDSELECT
;DEBUGPRINTFORML LOCALS:%LOCALS%
CALLFORM SLG_AI_CREATE_PROPOSAL_BY_%LOCALS%(LOCAL)


;-----------------------------------
;攻撃候補上位10作成
;ARG:0 1大きい 0小さい
;-----------------------------------
@SLG_AI_CREATE_PROPOSAL_BY_ECONOMY(ARG:0)
#DIM ECONOMY, MAX_CITY
VARSET ECONOMY
;DEBUGPRINTFORML SLG_AI_CREATE_PROPOSAL_BY_ECONOMY開始
FOR LOCAL, 0, MAX_CITY
	IF AI_TARGET_CITY:LOCAL == 0
		ECONOMY:(LOCAL:0) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		ECONOMY:LOCAL = CITY_ECONOMY:(AI_TARGET_CITY:(LOCAL))
		SIF CONFIG:300 == 3 && CITY_OWNER:LOCAL == CFLAG:MASTER:1
			ECONOMY:LOCAL = ECONOMY:LOCAL * (ARG:0 ? 15 # 5) / 10
		;DEBUGPRINTFORML ECONOMY:{LOCAL} {ECONOMY:LOCAL}
	ENDIF
NEXT
FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
	LOCAL:1 = ARG:0 ? MAXARRAY(ECONOMY) # MINARRAY(ECONOMY)
	IF (ARG:0 && LOCAL:1 != __INT_MIN__) || (!ARG:0 && LOCAL:1 != __INT_MAX__)
		LOCAL:1 = FINDELEMENT(ECONOMY, LOCAL:1)
		AI_TARGET_PROPOSED:LOCAL = AI_TARGET_CITY:(LOCAL:1)
		ECONOMY:(LOCAL:1) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		BREAK
	ENDIF
NEXT

@SLG_AI_CREATE_PROPOSAL_BY_GUARD(ARG:0)
#DIM GUARD, MAX_CITY
VARSET GUARD
;DEBUGPRINTFORML SLG_AI_CREATE_PROPOSAL_BY_GUARD開始
FOR LOCAL, 0, MAX_CITY
	IF AI_TARGET_CITY:LOCAL == 0
		GUARD:(LOCAL:0) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		GUARD:LOCAL = CITY_GUARD:(AI_TARGET_CITY:(LOCAL))
		SIF CONFIG:300 == 3 && CITY_OWNER:LOCAL == CFLAG:MASTER:1
			GUARD:LOCAL = GUARD:LOCAL * (ARG:0 ? 15 # 5) / 10
		;DEBUGPRINTFORML GUARD:{LOCAL} {GUARD:LOCAL}
	ENDIF
NEXT
FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
	LOCAL:1 = ARG:0 ? MAXARRAY(GUARD) # MINARRAY(GUARD)
	IF (ARG:0 && LOCAL:1 != __INT_MIN__) || (!ARG:0 && LOCAL:1 != __INT_MAX__)
		LOCAL:1 = FINDELEMENT(GUARD, LOCAL:1)
		AI_TARGET_PROPOSED:LOCAL = AI_TARGET_CITY:(LOCAL:1)
		GUARD:(LOCAL:1) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		BREAK
	ENDIF
NEXT


@SLG_AI_CREATE_PROPOSAL_BY_ARMY(ARG:0)
#DIM ARMY, MAX_CITY
VARSET ARMY
;DEBUGPRINTFORML SLG_AI_CREATE_PROPOSAL_BY_ARMY開始
FOR LOCAL, 0, MAX_CITY
	IF AI_TARGET_CITY:LOCAL == 0
		ARMY:(LOCAL:0) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		ARMY:LOCAL = GET_SUM_SOLDIER(CITY_OWNER:(AI_TARGET_CITY:(LOCAL)))
		SIF CONFIG:300 == 3 && CITY_OWNER:LOCAL == CFLAG:MASTER:1
			ARMY:LOCAL = ARMY:LOCAL * (ARG:0 ? 15 # 5) / 10
		;DEBUGPRINTFORML ARMY:{LOCAL} {ARMY:LOCAL}
	ENDIF
NEXT
FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
	LOCAL:1 = ARG:0 ? MAXARRAY(ARMY) # MINARRAY(ARMY)
	IF (ARG:0 && LOCAL:1 != __INT_MIN__) || (!ARG:0 && LOCAL:1 != __INT_MAX__)
		LOCAL:1 = FINDELEMENT(ARMY, LOCAL:1)
		AI_TARGET_PROPOSED:LOCAL = AI_TARGET_CITY:(LOCAL:1)
		ARMY:(LOCAL:1) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		BREAK
	ENDIF
NEXT


@SLG_AI_CREATE_PROPOSAL_BY_LINE(ARG:0)
#DIM LINE, MAX_CITY
VARSET LINE
;DEBUGPRINTFORML SLG_AI_CREATE_PROPOSAL_BY_LINE開始
FOR LOCAL, 0, MAX_CITY
	IF AI_TARGET_CITY:LOCAL == 0
		LINE:(LOCAL:0) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		LINE:LOCAL = AI_LINE_ONGET:LOCAL
		SIF CONFIG:300 == 3 && CITY_OWNER:LOCAL == CFLAG:MASTER:1
			LINE:LOCAL += ARG:0 ? 1 # -1
		;DEBUGPRINTFORML LINE:{LOCAL} {LINE:LOCAL}
	ENDIF
NEXT
FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
	LOCAL:1 = ARG:0 ? MAXARRAY(LINE) # MINARRAY(LINE)
	IF (ARG:0 && LOCAL:1 != __INT_MIN__) || (!ARG:0 && LOCAL:1 != __INT_MAX__)
		LOCAL:1 = FINDELEMENT(LINE, LOCAL:1)
		AI_TARGET_PROPOSED:LOCAL = AI_TARGET_CITY:(LOCAL:1)
		LINE:(LOCAL:1) = ARG:0 ? __INT_MIN__ # __INT_MAX__
	ELSE
		BREAK
	ENDIF
NEXT


@SLG_AI_CREATE_PROPOSAL_BY_RANDOM(ARG:0)
#DIM CNT
VARSET CNT
;DEBUGPRINTFORML SLG_AI_CREATE_PROPOSAL_BY_RAND開始
FOR LOCAL, 0, MAX_CITY
	SIF AI_TARGET_CITY:LOCAL == 0
		BREAK
	CNT ++
NEXT
CALL FISHER_YATES_SHAFFLE(CNT)
FOR LOCAL, 0, MIN(CNT, VARSIZE("AI_TARGET_PROPOSED"))
	AI_TARGET_PROPOSED:LOCAL = AI_TARGET_CITY:(SHAFFLE_ARRAY:(LOCAL))
NEXT

;-----------------------------------
;攻撃候補決定
;-----------------------------------

@SLG_AI_DECIDE_TARGET(ARG:0)
#DIM WORK, VARSIZE("AI_TARGET_PROPOSED")
[IF_DEBUG]
FOR LOCAL:0, 0, VARSIZE("AI_TARGET_PROPOSED")
	;DEBUGPRINTFORML AI_TARGET_PROPOSED:{LOCAL} {AI_TARGET_PROPOSED:LOCAL}
NEXT
[ENDIF]
;無所属、瀕死を優先して狙う
FOR LOCAL:0, 0, VARSIZE("AI_TARGET_PROPOSED")
	SIF AI_TARGET_PROPOSED:LOCAL == 0
		BREAK
	;無所属都市の検索
	IF CITY_OWNER:(AI_TARGET_PROPOSED:LOCAL) == 0 && RAND:100 < 60
		;DEBUGPRINTL 無所属都市による決定
		LOCAL:1 = LOCAL
		GOTO DECIDED
	ENDIF
	;瀕死勢力
	IF GET_OWN_CITY(CITY_OWNER:(AI_TARGET_PROPOSED:LOCAL)) == 1 && DAY >= 20 && RAND:100 < 50
		;DEBUGPRINTL 瀕死都市による決定
		LOCAL:1 = LOCAL
		GOTO DECIDED
	ENDIF
NEXT

;侵攻先の決定
SELECTCASE RAND:100
;リストのトップ
CASE IS < 80
	;DEBUGPRINTFORML 一位による決定
	LOCAL:1 = 0
;最も関係の悪い勢力
CASE 80 TO 89
	FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
		IF AI_TARGET_PROPOSED:LOCAL == 0
			WORK:LOCAL = __INT_MAX__
		;無所属都市のパターン
		ELSEIF GET_COUNTRY_BOSS(CITY_OWNER:(AI_TARGET_PROPOSED:LOCAL)) == -1
			WORK:LOCAL = __INT_MAX__
		ELSE
			WORK:LOCAL = REL_LIKE:(GET_COUNTRY_BOSS(ARG:0)):(GET_COUNTRY_BOSS(CITY_OWNER:(AI_TARGET_PROPOSED:LOCAL))) - REL_HATE:(GET_COUNTRY_BOSS(ARG:0)):(GET_COUNTRY_BOSS(CITY_OWNER:(AI_TARGET_PROPOSED:LOCAL)))
		ENDIF
	NEXT
	;DEBUGPRINTFORML 関係による決定
	LOCAL:1 = MINARRAY(WORK)
	LOCAL:1 = FINDELEMENT(WORK, LOCAL:1)
;最も経済力の低い勢力
CASE 90 TO 95
	FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
		IF AI_TARGET_PROPOSED:LOCAL == 0
			WORK:LOCAL = __INT_MAX__
		ELSE
			WORK:LOCAL = GET_SUM_ECONOMY(CITY_OWNER:(AI_TARGET_PROPOSED:LOCAL))
		ENDIF
	NEXT
	;DEBUGPRINTFORML 経済による決定
	LOCAL:1 = MINARRAY(WORK)
	LOCAL:1 = FINDELEMENT(WORK, LOCAL:1)
;;決まっていなければ、戦線の広がりが最小
CASEELSE
	FOR LOCAL, 0, VARSIZE("AI_TARGET_PROPOSED")
		IF AI_TARGET_PROPOSED:LOCAL == 0
			WORK:LOCAL = __INT_MAX__
		ELSE
			LOCAL:1 = FINDELEMENT(AI_TARGET_CITY, AI_TARGET_PROPOSED:LOCAL)
			WORK:LOCAL = AI_LINE_ONGET:(LOCAL:1)
		ENDIF
	NEXT
	LOCAL:1 = MINARRAY(WORK)
	LOCAL:1 = FINDELEMENT(WORK, LOCAL:1)
ENDSELECT

$DECIDED
;DEBUGPRINTFORML 選出されたAI_TARGET_PROPOSED:{AI_TARGET_PROPOSED:(LOCAL:1)}
RETURN FINDELEMENT(AI_TARGET_CITY, AI_TARGET_PROPOSED:(LOCAL:1))

;-------------------------------------------------
;●侵攻用の遊撃部隊を作成
;現状、兵数等の条件を満たし続ける限り部隊を作り続ける
;-------------------------------------------------
@SLG_AI_INVASION_CREATEUNIT(ARG:0)
#DIM UNIT_NOM, 3
#DIM AI_TYPE
#DIM DEPLOY_VALUE, 2
VARSET LOCAL
VARSET DEPLOY_VALUE
AI_TYPE = COUNTRY_AI_TYPE:(ARG:0)
;DEBUGPRINTFORML 部隊作成に入る
;空いている部隊の番号のうち最も若い番号を取得
FOR LOCAL:10, 0, MAX_UNIT
	SIF UNIT_SOLDIER:(ARG:0):(LOCAL:10) <= 0
		GOTO DECIDED
	;DEBUGPRINTFORML {LOCAL:10}番は埋まっている
NEXT

$DECIDED

SIF LOCAL:10 == MAX_UNIT
	RETURN 0

;部隊に編成する兵数を決定
DEPLOY_VALUE:0 = AI_DEPLOY_PROPERTY:AI_TYPE:2 + (CONFIG:300 + CONFIG:312 * 2) * AI_DEPLOY_PROPERTY:AI_TYPE:4
DEPLOY_VALUE:1 = AI_DEPLOY_PROPERTY:AI_TYPE:3 + (CONFIG:300 + CONFIG:312 * 2) * AI_DEPLOY_PROPERTY:AI_TYPE:4

UNIT_NOM:0 = COUNTRY_SOLDIER:(ARG:0) * RAND(DEPLOY_VALUE:0, DEPLOY_VALUE:1) / 100
UNIT_NOM:1 = (AI_DEPLOY_PROPERTY:AI_TYPE:0 + (CONFIG:300 + CONFIG:312 * 2) * AI_DEPLOY_PROPERTY:AI_TYPE:1) / 2
UNIT_NOM:2 = AI_DEPLOY_PROPERTY:AI_TYPE:5 + (CONFIG:312 * 2 - CONFIG:300) * AI_DEPLOY_PROPERTY:AI_TYPE:6 + RAND:(AI_DEPLOY_PROPERTY:AI_TYPE:7 + 1)

UNIT_SOLDIER:(ARG:0):(LOCAL:10) = LIMIT(UNIT_NOM:0, UNIT_NOM:1, UNIT_NOM:2)

IF COUNTRY_SOLDIER:(ARG:0) < UNIT_SOLDIER:(ARG:0):(LOCAL:10)
	DEBUGPRINTFORML {DAY,3} 【兵数不足】{ARG:0}:%NAME:(GET_COUNTRY_BOSS(ARG:0))% 部隊{LOCAL:10} - 要求:{UNIT_SOLDIER:(ARG:0):(LOCAL:10)} 実数{COUNTRY_SOLDIER:(ARG:0)}
	CALL CLEAR_UNIT(ARG:0, LOCAL:10)
	RETURN 0
ENDIF

COUNTRY_SOLDIER:(ARG:0) -= UNIT_SOLDIER:(ARG:0):(LOCAL:10)
;DEBUGPRINTFORML {DAY,3} 【兵数】{ARG:0}:%NAME:(GET_COUNTRY_BOSS(ARG:0))% 部隊{LOCAL:10}:{UNIT_SOLDIER:(ARG:0):(LOCAL:10)}

;DEBUGPRINTFORML {LOCAL:10}部隊を新設
;DEBUGPRINTFORML 兵数:{UNIT_SOLDIER:(ARG:0):(LOCAL:10)}
;DEBUGPRINTFORML 目的地:%CITY_NAME:(UNIT_TARGET:(ARG:0):(LOCAL:10))%
;DEBUGPRINTFORML スタート:%CITY_NAME:(UNIT_POSITION:(ARG:0):(LOCAL:10))%
;部隊が最強となるような士官の組み合わせを得る
CALL TMP_CREATE_IS_FREE_MAP
;行動可能な士官の数をカウント
LOCAL:0 = 0

CALL CHECK_UNIT_COMMANDER_BEST(ARG:0)
IF GROUPMATCH(-1, UNIT_COMMANDER_BEST:0, UNIT_COMMANDER_BEST:1, UNIT_COMMANDER_BEST:2) == 3 && NOSAMES(COUNTRY_AI_TYPE:(ARG:0), AI_ホフゴブリン)
	DEBUGPRINTFORML {DAY,3} 【武将数0】{ARG:0}:%NAME:(GET_COUNTRY_BOSS(ARG:0))% 部隊{LOCAL:10} - {UNIT_COMMANDER_BEST:0}, {UNIT_COMMANDER_BEST:1}, {UNIT_COMMANDER_BEST:2}
	CALL CLEAR_UNIT(ARG:0, LOCAL:10)
	RETURN 0
ELSEIF UNIT_SOLDIER:(ARG:0):(LOCAL:10) == 0
	DEBUGPRINTFORML {DAY,3} 【兵数0】{ARG:0}:%NAME:(GET_COUNTRY_BOSS(ARG:0))% 部隊{LOCAL:10}
	CALL CLEAR_UNIT(ARG:0, LOCAL:10)
	RETURN 0
ENDIF

FOR LOCAL:0, 0, 3
	SIF UNIT_COMMANDER_BEST:(LOCAL:0) >= 0
		CALL SET_UNIT_COMMANDER(ARG:0, LOCAL:10, LOCAL:0, UNIT_COMMANDER_BEST:(LOCAL:0))
NEXT


RETURN 1

;-------------------------------------------------
;ARG:0勢力が国庫を消費して徴兵を行うかの判定
;ARG:1 判定タイミング(0:侵攻判定前, 1:侵攻判定終了後)
;
;-------------------------------------------------
@AI_DEPLOY_ARMY(ARG:0, ARG:1)
;自国の経済／兵数／徴兵限界／温存兵率／支配都市数
#DIM ECONOMY
#DIM MILITARY
#DIM MILITARY_LIMIT
#DIM MILITARY_PERCENTAGE
#DIM OWN_CITY
#DIM SELECTOR, 10
#DIM DEPLOY_COUNT
#DIM DOCTRINE, 2, 9

VARSET ECONOMY
VARSET MILITARY
VARSET MILITARY_LIMIT
VARSET MILITARY_PERCENTAGE
VARSET OWN_CITY
VARSET SELECTOR
VARSET DEPLOY_COUNT

DOCTRINE:0:0 = 100, 110, 95, 90, 125, 90, 80, 150, 80
DOCTRINE:1:0 = 100, 95, 110, 90, 90, 125, 80, 80, 150


ECONOMY = GET_SUM_ECONOMY(ARG:0)
MILITARY_LIMIT = ECONOMY / 10

OWN_CITY = MATCH(CITY_OWNER, ARG:0)

;動員レート：現在の経済規模の1～5%を消費することで兵力限界の2～10%の兵力を得る
;最大判定回数の決定
SELECTOR:0 = AI_DEPLOY:(COUNTRY_AI_TYPE:(ARG:0)):(ARG:1 ? 3 # 1)
SELECTOR:1 = RAND:(SELECTOR:0 / 2 + 1) + RAND:(SELECTOR:0 / 2 + SELECTOR:0 % 2 + 1)

SIF !SELECTOR:1
	RETURN 0

FOR SELECTOR:3, 0, SELECTOR:1
	DEPLOY_COUNT ++
	;現在の国庫が既定値（現在の経済規模のN%）未満であれば動員しない
	SIF MONEY:(ARG:0) < AI_DEPLOY:(COUNTRY_AI_TYPE:(ARG:0)):4 * ECONOMY * (RAND:41 + 80) / (100 * 100 * 100)
		BREAK

	MILITARY = GET_SUM_SOLDIER(ARG:0)
	MILITARY_PERCENTAGE = MILITARY * 100 / MILITARY_LIMIT
	;既に動員上限を超えていれば雇用しない
	SIF MILITARY_PERCENTAGE > AI_DEPLOY:(COUNTRY_AI_TYPE:(ARG:0)):(ARG:1 ? 2 # 0)
		BREAK

	;動員に支払う額、現在の経済値の1～5%
	SELECTOR:8 = RAND:3 + RAND:3 + 1 
	SELECTOR:9 = SELECTOR:8 * ECONOMY / (100 * 100)
	;金がないなら動員しない（上の段階で弾かれるのが普通）
	SIF MONEY:(ARG:0) < SELECTOR:9
		BREAK
	MONEY:(ARG:0) -= SELECTOR:9

	;動員処理
	SELECTOR:2 = SELECTOR:8 * MILITARY_LIMIT * DOCTRINE:(ARG:1 ? 1 # 0):(COUNTRY_POLICY:(ARG:0)) / (100 * 100)
	COUNTRY_SOLDIER:(ARG:0) += SELECTOR:2
	SELECTOR:4 += SELECTOR:2
	SELECTOR:5 += SELECTOR:9

NEXT
IF SELECTOR:4
	;DEBUGPRINTFORML {DAY, 3}【緊急動員（\@ARG:1 ? 防 # 攻 \@）】%NAME:(GET_COUNTRY_BOSS(ARG:0))%:支払{SELECTOR:5}/{ECONOMY / 100}→徴兵{SELECTOR:4}/{MILITARY_LIMIT}
	SIF ARG:0 == CFLAG:MASTER:1 || FLAG:1
		PRINTFORML %NAME:(GET_COUNTRY_BOSS(ARG:0))%は{SELECTOR:5}の資金を払い\@ARG:1 ? 防衛 # 侵攻 \@のために兵を{SELECTOR:4}動員しました
ENDIF

