;-------------------------------------------------
;野盗の処理
;-------------------------------------------------
@BANDIT_TURNEND(ARG:0)
#DIM 兵数
#DIM 増加量
#DIM 部隊番号
#DIM 出兵先
#DIM LCOUNT
#DIM 中継点の数
#DIM 接続都市所有者,2
#DIM 解散フラグ
#DIM 都市数, 3

VARSET LOCAL
VARSET 兵数
VARSET 部隊番号
VARSET 出兵先
VARSET 中継点の数
VARSET 解散フラグ
VARSET 都市数

;クールタイム減少処理と、このターンに割り当てたフラグ削除処理
FOR LCOUNT, 0, CHARANUM
	IF CFLAG:LCOUNT:所属 == ARG:0
		COOLTIME:LCOUNT:0 = MAX(COOLTIME:LCOUNT:0 - 1 , 0)
		ASSIGNED_THIS_TURN:LCOUNT:0 = 0
	ENDIF
NEXT

;野盗湧かない期間中だとなにもせずにおわる
SIF BANDIT_POP_SUSPENDED > 0
	RETURN 0

;DEBUGPRINTL 野盗ターンエンド
;各勢力の支配都市数を元に徴兵数及び編成時の兵数を決定
FOR LCOUNT, 1, MAX_COUNTRY
	SIF !IS_COUNTRY(LCOUNT)
		CONTINUE
	都市数:0 = GET_OWN_CITY(LCOUNT)
	ARRAYSORT 都市数, FORWARD
NEXT
;最大勢力の支配都市数と第2勢力の都市数の2倍を基準値として計算
都市数:0 = 都市数:1 * 2 + 都市数:2

;基準値の２乗の80から120%の徴兵、最大は最大兵数の5%（最大兵数はその時点での全都市の経済規模の1%）
増加量 = MIN(POWER(都市数:0, 2) * (80 + RAND:41) / 100, SUMARRAY(CITY_ECONOMY) / 2000)
COUNTRY_SOLDIER:(ARG:0) = MIN(SUMARRAY(CITY_ECONOMY) / 100, COUNTRY_SOLDIER:(ARG:0) + 増加量)

DEBUGPRINTFORML 【野盗徴兵:{DAY, 3}】:{都市数:0}, {都市数:1}, {都市数:2} / {増加量}

FOR LCOUNT, 0, MAX_UNIT
	IF UNIT_SOLDIER:(ARG:0):LCOUNT > 0
		接続都市所有者:0 = CITY_OWNER:(CITY_ROOT:(UNIT_POSITION:(ARG:0):LCOUNT):0)
		接続都市所有者:1 = CITY_OWNER:(CITY_ROOT:(UNIT_POSITION:(ARG:0):LCOUNT):1)
		;2都市の所有者が両方無所属勢力、ないし2都市の所有者が敵対関係にない(同盟とか、両方同じ国とか)場合は解散
		IF (!IS_COUNTRY(接続都市所有者:0) && !IS_COUNTRY(接続都市所有者:1)) || CHECK_COUNTRY_RELATION_F(接続都市所有者:0, 接続都市所有者:1)
			CALL CLEAR_UNIT(ARG:0, LCOUNT)
			解散フラグ = 1
		;そうでないなら兵数が増える
		ELSE
			TIMES UNIT_SOLDIER:(ARG:0):LCOUNT, 1.03
			UNIT_SOLDIER:(ARG:0):LCOUNT = MIN(UNIT_SOLDIER:(ARG:0):LCOUNT, 10000)
		ENDIF
	ENDIF
NEXT
;DEBUGPRINTFORML 野盗全体:{COUNTRY_SOLDIER:(ARG:0)}
;特定条件で出兵
IF DAY % 3 == 0 || 解散フラグ
	;空いている部隊を調べる
	;空いていたら部隊作成
	FOR LCOUNT, 0, MAX_UNIT
		IF UNIT_SOLDIER:(ARG:0):LCOUNT == 0
			部隊番号 = LCOUNT
			兵数 = MIN(COUNTRY_SOLDIER:(ARG:0) / 2, POWER(都市数:0, 2) * RAND(70, 120) / 10)
			DEBUGPRINTFORML 【野盗派兵:{DAY, 3}】:{兵数}
			UNIT_SOLDIER:(ARG:0):LCOUNT = 兵数
			COUNTRY_SOLDIER:(ARG:0)  -= 兵数
			;DEBUGPRINTFORML 兵数予定：{兵数}
			BREAK
		ENDIF
	NEXT
	;出兵していたら、中継地点から適当にチョイス
	;なおCITYは0番を空っぽにし、1から始める仕様。中継点を得る場合、ループは1から始めないといけない（それか、GET_CITY_NUMで得られる値に1を足さないといけない)
	IF 兵数
		FOR LCOUNT, 0, MAX_CITY
			;DEBUGPRINTFORML 配置場所探索中
			;接続先があることを、単に設定されていない場所と中継点との違いであるみなす
			IF CITY_TYPE:LCOUNT == 1 && CITY_ROOT:(LCOUNT):0
				;DEBUGPRINTFORML 接続先発見:{LCOUNT+GET_CITY_NUM()}
				;中継点を見つけたら、その2都市の所有者を取得する。
				接続都市所有者:0 = CITY_OWNER:(CITY_ROOT:(LCOUNT):0)
				接続都市所有者:1 = CITY_OWNER:(CITY_ROOT:(LCOUNT):1)
				;2都市の所有者が両方無所属勢力、ないし2都市の所有者が敵対関係にない(同盟とか、両方同じ国とか)場合は候補としない。
				IF (!IS_COUNTRY(接続都市所有者:0) && !IS_COUNTRY(接続都市所有者:1)) || CHECK_COUNTRY_RELATION_F(接続都市所有者:0, 接続都市所有者:1)
				ELSE
					;DEBUGPRINTFORML LOCAL:{LCOUNT - GET_CITY_NUM() - 1}
					LOCAL:(中継点の数) = LCOUNT
					中継点の数 ++
				ENDIF
			ENDIF
		NEXT
		;中継点の数が0なら諦める
		IF 中継点の数
			CALL FISHER_YATES_SHAFFLE(中継点の数)
			UNIT_POSITION:(ARG:0):部隊番号 = LOCAL:(SHAFFLE_ARRAY:0)
			;士官が行動可能な状態にあるかどうかのリストを作成
			CALL TMP_CREATE_IS_FREE_MAP
			;部隊が最強となるような士官の組み合わせを得る
			CALL CHECK_UNIT_COMMANDER_BEST(ARG:0)
			FOR LCOUNT, 0, 3
				SIF UNIT_COMMANDER_BEST:(LCOUNT) >= 0
					CALL SET_UNIT_COMMANDER(ARG:0, 部隊番号, LCOUNT, UNIT_COMMANDER_BEST:(LCOUNT))
			NEXT
			;DEBUGPRINTFORML LOCAL:SHAFFLE_ARRAY:0 {LOCAL:(SHAFFLE_ARRAY:0)}
			;DEBUGPRINTFORML %CITY_NAME:(LOCAL:(SHAFFLE_ARRAY:0))%に出兵
			;DEBUGPRINTFORML 兵数:{兵数}
		ELSE
			;DEBUGPRINTFORML 中継点なし。あきらめ
			UNIT_SOLDIER:(ARG:0):部隊番号 = 0
			COUNTRY_SOLDIER:(ARG:0) += 兵数
		ENDIF
	ENDIF
ENDIF
